<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ashwin Narayan on Ashwin Narayan</title>
    <link>http://www.ashwinnarayan.com/</link>
    <description>Recent content in Ashwin Narayan on Ashwin Narayan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Ashwin Narayan</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Real-Time Programming with Xenomai 3 - Part 1: Installation and Basic Setup</title>
      <link>http://www.ashwinnarayan.com/post/xenomai-realtime-programming/</link>
      <pubDate>Wed, 17 May 2017 00:07:36 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/xenomai-realtime-programming/</guid>
      <description>

&lt;p&gt;In my lab, we recently started moving away from Simulink&amp;rsquo;s Real-Time packages and towards Real-Time Linux for implementing the low level control of our robots. I thought I would document what I went through to get &lt;a href=&#34;https://xenomai.org/&#34; target=&#34;_blank&#34;&gt;Xenomai&lt;/a&gt; (A Real-Time framework for linux) working stably as a resource for others trying to get started on the same thing.&lt;/p&gt;

&lt;h2 id=&#34;what-is-real-time&#34;&gt;What is Real-Time?&lt;/h2&gt;

&lt;p&gt;The word &amp;ldquo;real-time&amp;rdquo; is used in a lot of different fields to mean different things. Some people also mistake real-time systems for high performance systems. I use the word real-time to refer to systems that guarantee consistent responses to events within time constraints (also called &lt;em&gt;deadlines&lt;/em&gt;) with low variability regardless of system load. This is something that&amp;rsquo;s not easy to do. A normal linux operating system is not real-time. Say you want to implement a program in C on a regular linux computer that toggles a pin on the parallel port every millisecond. A naive implementation would be as a simple loop that toggles the pin and waits for 1 millisecond. This may work OK most of the time but the moment the system is loaded by something else, the program may start running its loops slower because the process may be preempted by the kernel or be swapped out of memory in favor of another memory intensive program. A real-time operating system will be designed so that regardless of the system load, the program that toggles the pin can do the operation every millisecond give or take a few microseconds. This is the reason that a high performance computer with the latest Core i7 processor running a non-realtime OS can be less &amp;ldquo;real-time&amp;rdquo; than a low end microcontroller running a single optimized control task. Real-time systems are used in mission critical control systems such as those on fly-by-wire aircraft, satellites, exoplanetary rovers, cardiac pacemakers or car engine control units.&lt;/p&gt;

&lt;p&gt;A real-time operating system (RTOS) usually has an API for creating and running real-time tasks and uses a scheduling algorithm that&amp;rsquo;s different from what&amp;rsquo;s used by general purpose operating systems like Windows and Linux. There are many RTOSs in the wild. &lt;a href=&#34;https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems&#34; target=&#34;_blank&#34;&gt;Wikipedia has a great list of them.&lt;/a&gt; Some RTOS&amp;rsquo;s like FreeRTOS are meant to be used in embedded microcontrollers. Some - like RTLinux are used when the real-time application needs to be run on a full blown operating system. Using real-time with full operating systems also allow you to take advantage of a lot of existing software and functionality that the operating system will have like networking and math libraries like GSL.&lt;/p&gt;

&lt;h2 id=&#34;real-time-operating-systems-for-control&#34;&gt;Real-Time Operating Systems for Control&lt;/h2&gt;

&lt;p&gt;When implementing a control system such as a PID controller digitally, real-time response times become very important. One of the assumptions made when developing digital control systems is that of constant sampling time. When you implement a control loop in code, if the constant sampling rate assumption is not met or if the controller responds too late to changes in the system state, it could lead to the system becoming unstable.&lt;/p&gt;

&lt;p&gt;The choice of using Xenomai to implement our real time controllers was mostly due to the fact that it has very good documentation apart from being free and open source.&lt;/p&gt;

&lt;h2 id=&#34;installing-xenomai&#34;&gt;Installing Xenomai&lt;/h2&gt;

&lt;p&gt;To get Xenomai running on a linux system, you need to compile a modified kernel. I used Lubuntu 12.04 (which ships with kernel 3.2). The version of the kernel that I compiled is 3.18.20. Choose a version of the kernel that is close in version number to the one that the distribution ships with to minimize issues.&lt;/p&gt;

&lt;p&gt;Before starting, create a fresh folder to act as your workspace. Also make sure you have plenty of disk space available. The 3.18.20 kernel requires just over 11 GB of free disk space to compile successfully. Newer versions of the kernel need more. 20 GB should be safe.&lt;/p&gt;

&lt;p&gt;These are the steps that I&amp;rsquo;ve been following to get a freshly installed Lubuntu system working with xenomai. Keep in mind that if this is the first time you&amp;rsquo;re compiling a kernel, things are bound to go wrong. Be willing to debug your compilation patiently. I had to go through the compilation process dozens of times, making tweaks at each step to get my first successful kernel image.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Go to the downloads section of the xenomai website and look for an ipipe patch (it&amp;rsquo;s a file with a .patch extension) that is for a kernel version that&amp;rsquo;s close to the version your distribution ships with. This is the kernel version that you&amp;rsquo;ll be compiling.&lt;/li&gt;
&lt;li&gt;Go to kernel.org and download the version of the linux kernel that exactly matches the kernel version on the ipipe patch file name.&lt;/li&gt;
&lt;li&gt;Download the xenomai source from the xenomai website.&lt;/li&gt;
&lt;li&gt;Unzip the files into separate folders.&lt;/li&gt;
&lt;li&gt;Apply the xenomai patch to the kernel:
&lt;code&gt;xenomai-3.0.4/scripts/prepare-kernel.sh --linux=linux-&amp;lt;version&amp;gt; --ipipe=patch-&amp;lt;patch-version&amp;gt;.patch --arch=x86_64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the kernel source directory and run &lt;code&gt;make menuconfig&lt;/code&gt; and make the following changes:

&lt;ul&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; CPU Frequency Scaling - DISABLE&lt;/li&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; ACPI Support -&amp;gt; Processor - DISABLE&lt;/li&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; CPU Idle -&amp;gt; CPU Idle PM Support - DISABLE&lt;/li&gt;
&lt;li&gt;Device Drivers -&amp;gt; Input Device Support -&amp;gt; Generic Input Layer -&amp;gt; Miscellaneous Devices -&amp;gt; PC Speaker Support - DISABLE&lt;/li&gt;
&lt;li&gt;Processor type and features -&amp;gt; Processor family: Select the exact processor on the motherboard. This is important for things to work properly.&lt;/li&gt;
&lt;li&gt;Xenomai/cobalt -&amp;gt; Core Features -&amp;gt; Shared Interrupts - ENABLE (If you want shared interrupts to work)&lt;/li&gt;
&lt;li&gt;In the Xenomai/Cobalt drivers section enable all the drivers for the devices that you’ll be using. Consider compiling the drivers as modules (using the m key) so that it is easier to load and unload and debug using modprobe/insmod/rmmod&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Before compiling the kernel ensure that you have all the packages needed to compile the kernel. Use apt-get or any package manager.

&lt;ul&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;make&lt;/li&gt;
&lt;li&gt;Autoconf&lt;/li&gt;
&lt;li&gt;libtool&lt;/li&gt;
&lt;li&gt;kernel-package&lt;/li&gt;
&lt;li&gt;build-essential&lt;/li&gt;
&lt;li&gt;fakeroot&lt;/li&gt;
&lt;li&gt;dh-autoconf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the kernel source folder again and compile the kernel using the command: &lt;code&gt;sudo CONCURRENCY_LEVEL=8 CLEAN_SOURCE=no fakeroot make-kpkg --initrd --append-to-version -xenomai-realtime --revision 1.0 kernel_image kernel_headers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Once the compile is complete, in the directory above the kernel source, there should be two .deb files: One starting with linux-headers and one starting with linux-image. These are the kernel image and header debian packages that you can use to install the kernel.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;sudo dpkg -i &amp;lt;package-name&amp;gt;&lt;/code&gt; to install each of the packages&lt;/li&gt;
&lt;li&gt;Update the initramfs using the command &lt;code&gt;sudo update-initramfs -c -k &amp;lt;kernel-version&amp;gt;-xenomai-realtime &amp;amp;&amp;amp; sudo update-grub&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the unzipped xenomai source folder and run &lt;code&gt;sudo ./configure&lt;/code&gt; followed by &lt;code&gt;sudo make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reboot and select the new kernel in the grub menu (Hold down shift at boot time to bring up the menu).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If everything went well, xenomai should be installed on your system now. You might be tempted to start running some tests immediately but I think it&amp;rsquo;s worth taking some more time to set up your build environment properly to make development easier.&lt;/p&gt;

&lt;p&gt;Some important xenomai related executables (including xeno-config) are in the &lt;code&gt;/usr/xenomai/bin&lt;/code&gt; folder. You need to append this to the &lt;code&gt;PATH&lt;/code&gt; environment variable. The library files that the code is linked against are installed in the &lt;code&gt;/usr/xenomai/lib&lt;/code&gt; folder. You need to append this to the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable. My preferred way of doing this is to edit the ~/.bashrc file with export statements. Open up your .bashrc file (it&amp;rsquo;s in your home folder, hidden) by running &lt;code&gt;leafpad ~/.bashrc&lt;/code&gt; and add the following two lines to it at the end.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export PATH=”/usr/xenomai/bin:$PATH”
export LD_LIBRARY_PATH=”/usr/xenomai/lib:$LD_LIBRARY_PATH”&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When you try to run a compiled xenomai application afterwards, you will need to run it as superuser (using the sudo command). It might complain that it cannot find the library files. This is because environment variables are cleared when running a program as root. To fix this permanently:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Open up a terminal and go to the &lt;code&gt;/etc/ld.so.conf.d&lt;/code&gt; folder.&lt;/li&gt;
&lt;li&gt;Create a new file called xenomai.conf (as superuser)&lt;/li&gt;
&lt;li&gt;Add the line &lt;code&gt;/usr/xenomai/lib&lt;/code&gt; to the file.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;sudo ldconfig&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Now&lt;/em&gt; you can finally try to run some tests. If everything went well, running &lt;code&gt;sudo /usr/xenomai/bin/latency&lt;/code&gt; should run the latency test program that outputs some numbers on to the terminal that shows you the latency figures of your system. It should be in the tens of microseconds range (If not something&amp;rsquo;s wrong).&lt;/p&gt;

&lt;p&gt;The process of getting real-time linux with Xenomai or any other framework running for the first time can be a little painful but once your installation is stable, it&amp;rsquo;ll serve you well for a very long time. Once you have a working compiled kernel package, installation on future hardware will also go much faster.&lt;/p&gt;

&lt;p&gt;In Part 2 of this series of blog posts, I will go through the process of writing a simple periodic real-time task using Xenomai&amp;rsquo;s real-time API.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Controlling music playback with a Telegram Bot</title>
      <link>http://www.ashwinnarayan.com/project/telegram-bot-music-control/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/telegram-bot-music-control/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Generating VGA Signals using an FPGA</title>
      <link>http://www.ashwinnarayan.com/project/fpga-vga/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/fpga-vga/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Implementing Logistic Regression</title>
      <link>http://www.ashwinnarayan.com/project/logistic-regression/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/logistic-regression/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Modelling and Controlling a BB8 Droid</title>
      <link>http://www.ashwinnarayan.com/project/bb8-control/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/bb8-control/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Simulating the chaos of a double pendulum</title>
      <link>http://www.ashwinnarayan.com/project/double-pendulum-simulation/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/double-pendulum-simulation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Visualizing Self-Organizing Maps</title>
      <link>http://www.ashwinnarayan.com/project/som-animation/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/som-animation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Brand New Website!</title>
      <link>http://www.ashwinnarayan.com/post/welcome/</link>
      <pubDate>Sun, 14 May 2017 00:38:51 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/welcome/</guid>
      <description>&lt;p&gt;My old website was formatted a lot like an online resume - something I feel doesn&amp;rsquo;t quite fit me any more after I decided to join a PhD program. So I decided to refresh my website deisgn into something that fit my current research interests. I also wanted a platform where I could blog about my work and personal projects. I&amp;rsquo;ve read blogs by many active researchers and I feel that the informal tone and nature of a blog allows more accessible explanations of research than formal journal/conference papers - where the language can often be very terse and full of jargon. A few excellent research blogs that I was inspired by:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://studywolf.wordpress.com/&#34; target=&#34;_blank&#34;&gt;Studywolf&lt;/a&gt; - About robotics and control.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jeremykun.com/2014/01/17/how-to-conquer-tensorphobia/&#34; target=&#34;_blank&#34;&gt;Math ∩ Programming&lt;/a&gt; Math and programming&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://colah.github.io/&#34; target=&#34;_blank&#34;&gt;colah&amp;rsquo;s blog&lt;/a&gt; - A blog by a researcher at Google about machine learning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like for my old website, I decided to go with a static website which allows me to host the site for free using Github pages. I used a static site generator called &lt;a href=&#34;https://jekyllrb.com/&#34; target=&#34;_blank&#34;&gt;Jekyll&lt;/a&gt;. However, I found it a bit time consuming to use. I wanted to spend more time focusing on the content of the website and less on the setup. So I did a little research on other static site generators that I can use and came across &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt;. It seemed to have all the nice features that a static site generator should have. It works across all operatings systems, had a lot of free themes, was open source and most importantly was easy to set up. I was able to get a basic website generated in under two minutes by following their getting started tutorial. If you&amp;rsquo;re looking for a good static site generator, I highly recommend Hugo.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
