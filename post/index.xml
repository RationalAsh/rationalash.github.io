<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ashwin Narayan</title>
    <link>http://www.ashwinnarayan.com/post/</link>
    <description>Recent content in Posts on Ashwin Narayan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Ashwin Narayan</copyright>
    <lastBuildDate>Sun, 01 Jan 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ICRA 2017</title>
      <link>http://www.ashwinnarayan.com/post/icra-2017/</link>
      <pubDate>Mon, 05 Jun 2017 22:50:52 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/icra-2017/</guid>
      <description>

&lt;p&gt;The IEEE International Conference on Robotics and Automation (ICRA) that happened in Singapore over the last week is often referred to as &lt;em&gt;the&lt;/em&gt; robotics conference. If you&amp;rsquo;re an academic working in the field of robotics, Singapore was the place to be in the last week. So I spent most of my time hanging around the Marina Bay Sands Hotel Convention center as a student volunteer for the conference, helping out and - in my free time - attending some of the hundreds of presentations that that took place.&lt;/p&gt;

&lt;p&gt;One thing that completely blew me away was the scale of the event. It made me realize how vast human knowledge is and how my life&amp;rsquo;s entire work would just be a miniscule part of the sum total. Robotics itself is just a small portion of all there is to know. And even in a conference dedicated to this field, I had to sift through dozens to subfields to attend the talks that were relevant to my narrow area of research.&lt;/p&gt;

&lt;h2 id=&#34;day-1&#34;&gt;Day 1&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;The first day of the conference did not have any paper presentations. I guess they wanted to give the delegates from other countries time to get used to the place before they had to present their work. There were however, workshops on several different subjects that were going on. It was also one of the busiest days as a volunteer for me since I was helping out with the registrations of those coming in for the conference. I spent the day helping people get their conference ID tags (which were used for access control) and package. Instead of the usual thick booklet of the conference schedule, ICRA 2017 gave out to all the delegates an android tablet pre-loaded with an app that had the full conference schedule.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.ashwinnarayan.com/img/Registration-Desk.jpg&#34; alt=&#34;Registration Desk of ICRA 2017&#34; title=&#34;Caption&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Registration work ended at 4.30 and I had some time to catch the end of a very interesting workshop on rehabiliation robotics.&lt;/p&gt;

&lt;h2 id=&#34;days-2-4&#34;&gt;Days 2 - 4&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Days 2 - 4 were when the bulk of the conference happened. The papers were classified into sub topics and the presentations for each sub topic happened in different rooms. I feel like the organizers did a good job of separating the papers out in a way that prevented situations where you had two relevant sessions that you had to be in at the same time. After listening to many people presenting their work, I feel a little less nervous about the time I&amp;rsquo;ll have to present my own work in a conference. For the most part, people were friendly, interested and loved to discuss with you about your work after the presentation. In fact, I&amp;rsquo;ll say that I&amp;rsquo;m almost looking forward to my next conference so that I can discuss with interested people about my work.&lt;/p&gt;

&lt;p&gt;Conferences are also very intellectually stimulating! As I listened to the presentations I also found myself getting new ideas for how I could solve problems that I&amp;rsquo;m facing in my own work. And surprisingly, I had some of my more interesting ideas in sessions that were not directly related to my work. In my next conference I think I will also spend some time attending sessions that are not directly related to my area of research.&lt;/p&gt;

&lt;p&gt;While the technical sessions were fantastic, I enjoyed even more the brilliant talks that were arranged for the Keynote and Plenary sessions. These are talks arranged in the afternoons and in the mornings. I think that the organizers selected the works of some particularly brilliant people for these sessions. There were three talks that really stood out.&lt;/p&gt;

&lt;p&gt;My favorite talk was one by Professor Lourdes Agapito from University College London. She gave a talk on her work on extracting 3D information from static 2D photos and videos. This is something that&amp;rsquo;s &lt;em&gt;very&lt;/em&gt; difficult to do. The best camera sensor that does this is the Kinect and it has to use multiple cameras and an infra red pattern projected onto the scene to get depth information. This limits the range of the camera to a few feet. To get really good long range 3D reconstruction, you need to use a LIDAR - the sensors that self-driving cars use to sense the environment around them. That&amp;rsquo;s why I was so impressed by the quality of the 3D reconstruction that she was able to extract from images taken by just a single camera.&lt;/p&gt;

&lt;p&gt;I also really enjoyed the talk by Chris Gerdes from Stanford. Strapping a bunch of electronics on a DeLorean (among other cars) and making automatic control systems that can keep up with human racecar drivers (and even perform drifting maneuvers) is just pure awesomeness.&lt;/p&gt;

&lt;p&gt;The last Keynote on June 1 by Professor Katja Mombaur was in a category of its own. She talked about her work on developing very accurate dynamic models of human walking. As someone who spent a lot of time trying to understand the very hairy mathematics behind the dynamics of human walking, I could really appreciate the amount of effort that went into her research. It&amp;rsquo;s probably work that I will be referring to and using quite frequently during my PhD.&lt;/p&gt;

&lt;p&gt;There were also some robot competitions and an exhibition happening at the conference. I was expecting a lot from these but I didn&amp;rsquo;t find them as exciting as I thought I would. Maybe working in lab with lots of cool robots every day has rasied my standards of the kind of robotics demos that I find exciting. The robotics competitions were pretty interesting to watch though. Especially the block stacking challenge from DJI.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.ashwinnarayan.com/img/icra-collage.jpg&#34; alt=&#34;ICRA Collage&#34; title=&#34;Caption&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-5&#34;&gt;Day 5&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;The last day of the conference was a little quiet. A lot of the people had already left or were busy exploring Singapore. The few who stuck around were those interested in attending the workshops on the last day of the conference. I attended one focusing on Assistive robotics.&lt;/p&gt;

&lt;h2 id=&#34;worth-it&#34;&gt;Worth it?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Doing volunteer work in a conference is no easy task. I was on my feet through most of the 5 days and my feet were killing me at the end of the day. I don&amp;rsquo;t think I&amp;rsquo;ve ever walked more in my life than during the first four days of the conference. Your voice can also take quite a hit, especially if you&amp;rsquo;re working at the registration desk.&lt;/p&gt;

&lt;p&gt;On the whole though, I think it was definitely worth it. I&amp;rsquo;d have gladly done all that work for the amazing talks and technical presentations alone, but that was not all that made the conference worth attending. It felt amazing to be surrounded by so much technology and by people who love robotics as much as I do. Being a bit of an introvert, I&amp;rsquo;ve always found it difficult to do small talk with people. The conversation just doesn&amp;rsquo;t feel natural or interesting to me. In the conference however, I felt like I could walk up to almost anyone and start a conversation about something without feeling like I&amp;rsquo;m boring my conversation partner. A welcome change for someone used to people zoning out when I talk about things that interest me.&lt;/p&gt;

&lt;p&gt;Apart from the technical presentations, I also got to experience a really nice  9 course dinner, and free entry into the Night Safari and the flower dome in the Gardens By the Bay. So if you ever get an opportunity to become a student volunteer in a big conference like this in your field, go for it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Real-Time Programming with Xenomai 3 - Part 2: Writing a simple periodic task.</title>
      <link>http://www.ashwinnarayan.com/post/xenomai-realtime-programming-part-2/</link>
      <pubDate>Sat, 20 May 2017 23:10:16 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/xenomai-realtime-programming-part-2/</guid>
      <description>&lt;p&gt;Xenomai gets tasks to run in real-time by having a co-kernel running alongside the regular linux kernel handling all the time critical tasks. The Xenomai co-kernel is able to do this because of the i-pipe patch that the custom kernel is compiled with. This patch adds an &lt;em&gt;interrupt pipeline&lt;/em&gt; that sits between the hardware of the computer and any kernels running on the hardware. The interrupt pipeline has domains which can be assigned a priority. When any interrupt, system call or processor fault comes in, the domain with the higher priority is allowed to process them first. The Xenomai co-kernel has the higher priority in an ipipe patched kernel. The Xenomai website has a &lt;a href=&#34;https://xenomai.org/documentation/branches/v2.3.x/Life-with-Adeos-rev_B.pdf&#34; target=&#34;_blank&#34;&gt;more detailed explanation of how it works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before I start with the explanation, here&amp;rsquo;s the full code and Makefile for those who just want to compile some code and get started. The documentation for all the functions used in the code and more can be found &lt;a href=&#34;https://xenomai.org/documentation/xenomai-3/pdf/xeno3prm.pdf&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;alchemy/task.h&amp;gt;
#include &amp;lt;alchemy/timer.h&amp;gt;
#include &amp;lt;math.h&amp;gt;


#define CLOCK_RES 1e-9 //Clock resolution is 1 ns by default
#define LOOP_PERIOD 1e7 //Expressed in ticks
//RTIME period = 1000000000;
RT_TASK loop_task;

void loop_task_proc(void *arg)
{
  RT_TASK *curtask;
  RT_TASK_INFO curtaskinfo;
  int iret = 0;

  RTIME tstart, now;

  curtask = rt_task_self();
  rt_task_inquire(curtask, &amp;amp;curtaskinfo);
  int ctr = 0;

  //Print the info
  printf(&amp;quot;Starting task %s with period of 10 ms ....\n&amp;quot;, curtaskinfo.name);

  //Make the task periodic with a specified loop period
  rt_task_set_periodic(NULL, TM_NOW, LOOP_PERIOD);

  tstart = rt_timer_read();

  //Start the task loop
  while(1){
    printf(&amp;quot;Loop count: %d, Loop time: %.5f ms\n&amp;quot;, ctr, (rt_timer_read() - tstart)/1000000.0);
    ctr++;
    rt_task_wait_period(NULL);
  }
}

int main(int argc, char **argv)
{
  char str[20];

  //Lock the memory to avoid memory swapping for this program
  mlockall(MCL_CURRENT | MCL_FUTURE);
    
  printf(&amp;quot;Starting cyclic task...\n&amp;quot;);

  //Create the real time task
  sprintf(str, &amp;quot;cyclic_task&amp;quot;);
  rt_task_create(&amp;amp;loop_task, str, 0, 50, 0);

  //Since task starts in suspended mode, start task
  rt_task_start(&amp;amp;loop_task, &amp;amp;loop_task_proc, 0);

  //Wait for Ctrl-C
  pause();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;SKIN=alchemy
MAIN_SRC=cyclic_test
TARGET=cyclic_test

LM=-lm

CFLAGS := $(shell xeno-config --skin=alchemy --cflags)
LDFLAGS := $(LM) $(shell xeno-config --skin=alchemy --ldflags)
CC := $(shell xeno-config --cc)

$(TARGET): $(MAIN_SRC).c
	$(CC) -o $@ $&amp;lt; $(CFLAGS) $(LDFLAGS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, the headers, defines and global variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;alchemy/task.h&amp;gt;
#include &amp;lt;alchemy/timer.h&amp;gt;
#include &amp;lt;math.h&amp;gt;


#define CLOCK_RES 1e-9 //Clock resolution is 1 ns by default
#define LOOP_PERIOD 1e7 //Expressed in ticks
//RTIME period = 1000000000;
RT_TASK loop_task;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The includes are fairly standard. The Xenomai libraries are included by the &lt;code&gt;alchemy/task.h&lt;/code&gt; and the &lt;code&gt;alchemy/timer.h&lt;/code&gt; statements. I&amp;rsquo;ve deifined CLOCK_RES (The resolution of the clock) and LOOP_PERIOD (The period with which I want the periodic task to run) for convenience. The variable &lt;code&gt;RT_TASK loop_task&lt;/code&gt; will hold an address to a task descriptor for a Real-Time task/thread that Xenomai will create.&lt;/p&gt;

&lt;p&gt;Jumping ahead to &lt;code&gt;main()&lt;/code&gt;, the first line that you come across that might be unfamiliar is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;  //Lock the memory to avoid memory swapping for this program
  mlockall(MCL_CURRENT | MCL_FUTURE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The mlockall() function is actually a function provided by linux rather than Xenomai and is provided by the &lt;code&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/code&gt; include. In Part one, I talked about how a real-time task can miss its deadlines if the task is swapped out of memory by the operating system. This line of code makes sure that the memory that is currently mapped to the address space of the process as well as any memory that gets mapped into the address space of the process in the future is &amp;ldquo;locked&amp;rdquo; into RAM and cannot get swapped out.&lt;/p&gt;

&lt;p&gt;In the next few lines of code, a new real-time task is created.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;  //Create the real time task
  sprintf(str, &amp;quot;cyclic_task&amp;quot;);
  rt_task_create(&amp;amp;loop_task, str, 0, 50, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rt_task_create() function creates a new real-time task using Xenoma&amp;rsquo;s Alchemy API. The first argument is the RT_TASK variable that holds the address of the task descriptor. The second is a string that holds a name for the task. You can give it a descriptive name. The third argument is the size of the stack for the new task. Passing a zero makes the function use a system dependent default. The next argument is the &lt;em&gt;priority&lt;/em&gt; of the task. This tells the real-time scheduler how important the task is. Higher priority tasks can interrupt lower priority tasks. The last argument is the task creation mode into which you can pass bitwise OR&amp;rsquo;ed flags. For example, passing the T_JOINABLE flag allows you to call the rt_task_join() function to wait on the task to finish. In this code sample, I&amp;rsquo;m just passing in zero, which is the default mode. The function returns a 0 if the task is successfully created. Ideally, you should check for this and print an error if the return value is not zero. However, for this simple example, I&amp;rsquo;m omitting this.&lt;/p&gt;

&lt;p&gt;A real-time task created using rt_task_create() starts off dormant. To begin the execution of the task, you need to call the rt_task_start() function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;  //Since task starts in suspended mode, start task
  rt_task_start(&amp;amp;loop_task, &amp;amp;loop_task_proc, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two arguments are the task descriptor and a pointer to the function that implements the real-time task. The last argument is a pointer to a user defined struct that will be passed on as arguments to the real-time task function.&lt;/p&gt;

&lt;p&gt;Finally we call the pause() function and wait for a Ctrl-C signal from the terminal.&lt;/p&gt;

&lt;p&gt;Once rt_task_start() is called, the real-time task starts executing. To make a Xenomai task periodic, you need to call the rt_task_set_periodic() function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; //Make the task periodic with a specified loop period
  rt_task_set_periodic(NULL, TM_NOW, LOOP_PERIOD);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re calling this function from outside a real-time task, you need to pass in an RT_TASK as the first argument. However, you can also call this function from inside a real-time task with a &lt;code&gt;NULL&lt;/code&gt; first argument. &lt;code&gt;TM_NOW&lt;/code&gt; tells Xenomai to start timing the task right away and LOOP period is the period of the task in ticks of the clock. Since the default resolution of the clock is 1 nanosecond, this argument is the same as the period you want for the task expressed in nanoseconds.&lt;/p&gt;

&lt;p&gt;Now we can start the infinite loop of the task.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//Start the task loop
  while(1){
    printf(&amp;quot;Loop count: %d, Loop time: %.5f ms\n&amp;quot;, ctr, (rt_timer_read() - tstart)/1000000.0);
    ctr++;
    rt_task_wait_period(NULL);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the loop I increment a simple counter and also use the rt_timer_read() function to get the current system time so I can print to the terminal and check if the task is running in real-time. The rt_task_wait_period() blocks the loop till the start of the next period.&lt;/p&gt;

&lt;p&gt;When I started out trying to compile and run Xenomai with no prior experience, it seemed like quite a daunting task. The Xenomai documentation although excellent is written for programmers and as a result, it can be difficult to write your very first program. However, once you do write your very first program and you get a good idea for how it works, things go very smoothly. This post, like the one before is a bit long but hopefully, someone trying to get started with Xenomai for the first time will find it useful!&lt;/p&gt;

&lt;p&gt;So I was going over your options when it comes to leaving that place over the last week and here&amp;rsquo;s the info that I&amp;rsquo;ve found so far:&lt;/p&gt;

&lt;p&gt;Most of the people who go to the US to study are not super rich. They just make use of all the funding opportunities they get. From what I read, the options are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Scholarships: There are quite a few scholarships flying around. Apply for &lt;em&gt;all&lt;/em&gt; of them. You never know which one you&amp;rsquo;re going to get. Don&amp;rsquo;t not apply to them because you feel like you&amp;rsquo;re not qualified enough to get the scholarship.&lt;/li&gt;
&lt;li&gt;Loans: Most students take loans for their living and initial expenses even if they get scholarships.&lt;/li&gt;
&lt;li&gt;GA/TA : So there are some universities that have this program where if you do graduate and teaching assistant work, your tuition fee is waived and you get a small stipend to live on. Some universities will tell you if you&amp;rsquo;re selected for the GA program when they give you the admit/offer.&lt;/li&gt;
&lt;li&gt;Part time jobs: You can work for up to 20 hours a week on the student visa. This should be the last option as it will make things more difficult for you during the course and you need time to focus on your studies.&lt;/li&gt;
&lt;li&gt;Internships : If you get a really good internship you can make good money during the holidays that will give you some money.&lt;/li&gt;
&lt;li&gt;Going for Europe: A lot of places in Europe have universities with no tuition fee. &lt;em&gt;Especially&lt;/em&gt; Germany. Also, a lot of these universities also have financial aid/scholarship/grant programs. Scholarships are given, grants are like interest free loans.&lt;/li&gt;
&lt;li&gt;Going for some place in India: If you have some place in India that has the courses that you&amp;rsquo;re looking for, then you can try for that. Since banks will give you loans of up to 20l without collateral, and most masters programs in India won&amp;rsquo;t cost that much, you can easily have your expenses fall within the loan amount.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I do think that if you&amp;rsquo;re planning on leaving Reliance, it&amp;rsquo;s a good option to work with the Detect technologies for maybe a year (or more if you find the work interesting and you get good experience). You can expand your options a little bit and you can get exposure to more areas of work that you might find interesting. you never know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Real-Time Programming with Xenomai 3 - Part 1: Installation and Basic Setup</title>
      <link>http://www.ashwinnarayan.com/post/xenomai-realtime-programming/</link>
      <pubDate>Wed, 17 May 2017 00:07:36 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/xenomai-realtime-programming/</guid>
      <description>

&lt;p&gt;In my lab, we recently started moving away from Simulink&amp;rsquo;s Real-Time packages and towards Real-Time Linux for implementing the low level control of our robots. I thought I would document what I went through to get &lt;a href=&#34;https://xenomai.org/&#34; target=&#34;_blank&#34;&gt;Xenomai&lt;/a&gt; (A Real-Time framework for linux) working stably as a resource for others trying to get started on the same thing.&lt;/p&gt;

&lt;h2 id=&#34;what-is-real-time&#34;&gt;What is Real-Time?&lt;/h2&gt;

&lt;p&gt;The word &amp;ldquo;real-time&amp;rdquo; is used in a lot of different fields to mean different things. Some people also mistake real-time systems for high performance systems. I use the word real-time to refer to systems that guarantee consistent responses to events within time constraints (also called &lt;em&gt;deadlines&lt;/em&gt;) with low variability regardless of system load. This is something that&amp;rsquo;s not easy to do. A normal linux operating system is not real-time. Say you want to implement a program in C on a regular linux computer that toggles a pin on the parallel port every millisecond. A naive implementation would be as a simple loop that toggles the pin and waits for 1 millisecond. This may work OK most of the time but the moment the system is loaded by something else, the program may start running its loops slower because the process may be preempted by the kernel or be swapped out of memory in favor of another memory intensive program. A real-time operating system will be designed so that regardless of the system load, the program that toggles the pin can do the operation every millisecond give or take a few microseconds. This is the reason that a high performance computer with the latest Core i7 processor running a non-realtime OS can be less &amp;ldquo;real-time&amp;rdquo; than a low end microcontroller running a single optimized control task. Real-time systems are used in mission critical control systems such as those on fly-by-wire aircraft, satellites, exoplanetary rovers, cardiac pacemakers or car engine control units.&lt;/p&gt;

&lt;p&gt;A real-time operating system (RTOS) usually has an API for creating and running real-time tasks and uses a scheduling algorithm that&amp;rsquo;s different from what&amp;rsquo;s used by general purpose operating systems like Windows and Linux. There are many RTOSs in the wild. &lt;a href=&#34;https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems&#34; target=&#34;_blank&#34;&gt;Wikipedia has a great list of them.&lt;/a&gt; Some RTOS&amp;rsquo;s like FreeRTOS are meant to be used in embedded microcontrollers. Some - like RTLinux are used when the real-time application needs to be run on a full blown operating system. Using real-time with full operating systems also allow you to take advantage of a lot of existing software and functionality that the operating system will have like networking and math libraries like GSL.&lt;/p&gt;

&lt;h2 id=&#34;real-time-operating-systems-for-control&#34;&gt;Real-Time Operating Systems for Control&lt;/h2&gt;

&lt;p&gt;When implementing a control system such as a PID controller digitally, real-time response times become very important. One of the assumptions made when developing digital control systems is that of constant sampling time. When you implement a control loop in code, if the constant sampling rate assumption is not met or if the controller responds too late to changes in the system state, it could lead to the system becoming unstable.&lt;/p&gt;

&lt;p&gt;The choice of using Xenomai to implement our real time controllers was mostly due to the fact that it has very good documentation apart from being free and open source.&lt;/p&gt;

&lt;h2 id=&#34;installing-xenomai&#34;&gt;Installing Xenomai&lt;/h2&gt;

&lt;p&gt;To get Xenomai running on a linux system, you need to compile a modified kernel. I used Lubuntu 12.04 (which ships with kernel 3.2). The version of the kernel that I compiled is 3.18.20. Choose a version of the kernel that is close in version number to the one that the distribution ships with to minimize issues.&lt;/p&gt;

&lt;p&gt;Before starting, create a fresh folder to act as your workspace. Also make sure you have plenty of disk space available. The 3.18.20 kernel requires just over 11 GB of free disk space to compile successfully. Newer versions of the kernel need more. 20 GB should be safe.&lt;/p&gt;

&lt;p&gt;These are the steps that I&amp;rsquo;ve been following to get a freshly installed Lubuntu system working with xenomai. Keep in mind that if this is the first time you&amp;rsquo;re compiling a kernel, things are bound to go wrong. Be willing to debug your compilation patiently. I had to go through the compilation process dozens of times, making tweaks at each step to get my first successful kernel image.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Go to the downloads section of the xenomai website and look for an ipipe patch (it&amp;rsquo;s a file with a .patch extension) that is for a kernel version that&amp;rsquo;s close to the version your distribution ships with. This is the kernel version that you&amp;rsquo;ll be compiling.&lt;/li&gt;
&lt;li&gt;Go to kernel.org and download the version of the linux kernel that exactly matches the kernel version on the ipipe patch file name.&lt;/li&gt;
&lt;li&gt;Download the xenomai source from the xenomai website.&lt;/li&gt;
&lt;li&gt;Unzip the files into separate folders.&lt;/li&gt;
&lt;li&gt;Apply the xenomai patch to the kernel:
&lt;code&gt;xenomai-3.0.4/scripts/prepare-kernel.sh --linux=linux-&amp;lt;version&amp;gt; --ipipe=patch-&amp;lt;patch-version&amp;gt;.patch --arch=x86_64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the kernel source directory and run &lt;code&gt;make menuconfig&lt;/code&gt; and make the following changes:

&lt;ul&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; CPU Frequency Scaling - DISABLE&lt;/li&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; ACPI Support -&amp;gt; Processor - DISABLE&lt;/li&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; CPU Idle -&amp;gt; CPU Idle PM Support - DISABLE&lt;/li&gt;
&lt;li&gt;Device Drivers -&amp;gt; Input Device Support -&amp;gt; Generic Input Layer -&amp;gt; Miscellaneous Devices -&amp;gt; PC Speaker Support - DISABLE&lt;/li&gt;
&lt;li&gt;Processor type and features -&amp;gt; Processor family: Select the exact processor on the motherboard. This is important for things to work properly.&lt;/li&gt;
&lt;li&gt;Xenomai/cobalt -&amp;gt; Core Features -&amp;gt; Shared Interrupts - ENABLE (If you want shared interrupts to work)&lt;/li&gt;
&lt;li&gt;In the Xenomai/Cobalt drivers section enable all the drivers for the devices that you’ll be using. Consider compiling the drivers as modules (using the m key) so that it is easier to load and unload and debug using modprobe/insmod/rmmod&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Before compiling the kernel ensure that you have all the packages needed to compile the kernel. Use apt-get or any package manager.

&lt;ul&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;make&lt;/li&gt;
&lt;li&gt;Autoconf&lt;/li&gt;
&lt;li&gt;libtool&lt;/li&gt;
&lt;li&gt;kernel-package&lt;/li&gt;
&lt;li&gt;build-essential&lt;/li&gt;
&lt;li&gt;fakeroot&lt;/li&gt;
&lt;li&gt;dh-autoconf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the kernel source folder again and compile the kernel using the command: &lt;code&gt;sudo CONCURRENCY_LEVEL=8 CLEAN_SOURCE=no fakeroot make-kpkg --initrd --append-to-version -xenomai-realtime --revision 1.0 kernel_image kernel_headers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Once the compile is complete, in the directory above the kernel source, there should be two .deb files: One starting with linux-headers and one starting with linux-image. These are the kernel image and header debian packages that you can use to install the kernel.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;sudo dpkg -i &amp;lt;package-name&amp;gt;&lt;/code&gt; to install each of the packages&lt;/li&gt;
&lt;li&gt;Update the initramfs using the command &lt;code&gt;sudo update-initramfs -c -k &amp;lt;kernel-version&amp;gt;-xenomai-realtime &amp;amp;&amp;amp; sudo update-grub&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the unzipped xenomai source folder and run &lt;code&gt;sudo ./configure&lt;/code&gt; followed by &lt;code&gt;sudo make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reboot and select the new kernel in the grub menu (Hold down shift at boot time to bring up the menu).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If everything went well, xenomai should be installed on your system now. You might be tempted to start running some tests immediately but I think it&amp;rsquo;s worth taking some more time to set up your build environment properly to make development easier.&lt;/p&gt;

&lt;p&gt;Some important xenomai related executables (including xeno-config) are in the &lt;code&gt;/usr/xenomai/bin&lt;/code&gt; folder. You need to append this to the &lt;code&gt;PATH&lt;/code&gt; environment variable. The library files that the code is linked against are installed in the &lt;code&gt;/usr/xenomai/lib&lt;/code&gt; folder. You need to append this to the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable. My preferred way of doing this is to edit the ~/.bashrc file with export statements. Open up your .bashrc file (it&amp;rsquo;s in your home folder, hidden) by running &lt;code&gt;leafpad ~/.bashrc&lt;/code&gt; and add the following two lines to it at the end.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export PATH=”/usr/xenomai/bin:$PATH”
export LD_LIBRARY_PATH=”/usr/xenomai/lib:$LD_LIBRARY_PATH”&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When you try to run a compiled xenomai application afterwards, you will need to run it as superuser (using the sudo command). It might complain that it cannot find the library files. This is because environment variables are cleared when running a program as root. To fix this permanently:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Open up a terminal and go to the &lt;code&gt;/etc/ld.so.conf.d&lt;/code&gt; folder.&lt;/li&gt;
&lt;li&gt;Create a new file called xenomai.conf (as superuser)&lt;/li&gt;
&lt;li&gt;Add the line &lt;code&gt;/usr/xenomai/lib&lt;/code&gt; to the file.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;sudo ldconfig&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Now&lt;/em&gt; you can finally try to run some tests. If everything went well, running &lt;code&gt;sudo /usr/xenomai/bin/latency&lt;/code&gt; should run the latency test program that outputs some numbers on to the terminal that shows you the latency figures of your system. It should be in the tens of microseconds range (If not something&amp;rsquo;s wrong).&lt;/p&gt;

&lt;p&gt;The process of getting real-time linux with Xenomai or any other framework running for the first time can be a little painful but once your installation is stable, it&amp;rsquo;ll serve you well for a very long time. Once you have a working compiled kernel package, installation on future hardware will also go much faster.&lt;/p&gt;

&lt;p&gt;In Part 2 of this series of blog posts, I will go through the process of writing a simple periodic real-time task using Xenomai&amp;rsquo;s real-time API.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Brand New Website!</title>
      <link>http://www.ashwinnarayan.com/post/welcome/</link>
      <pubDate>Sun, 14 May 2017 00:38:51 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/welcome/</guid>
      <description>&lt;p&gt;My old website was formatted a lot like an online resume - something I feel doesn&amp;rsquo;t quite fit me any more after I decided to join a PhD program. So I decided to refresh my website deisgn into something that fit my current research interests. I also wanted a platform where I could blog about my work and personal projects. I&amp;rsquo;ve read blogs by many active researchers and I feel that the informal tone and nature of a blog allows more accessible explanations of research than formal journal/conference papers - where the language can often be very terse and full of jargon. A few excellent research blogs that I was inspired by:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://studywolf.wordpress.com/&#34; target=&#34;_blank&#34;&gt;Studywolf&lt;/a&gt; - About robotics and control.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jeremykun.com/2014/01/17/how-to-conquer-tensorphobia/&#34; target=&#34;_blank&#34;&gt;Math ∩ Programming&lt;/a&gt; Math and programming&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://colah.github.io/&#34; target=&#34;_blank&#34;&gt;colah&amp;rsquo;s blog&lt;/a&gt; - A blog by a researcher at Google about machine learning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Like for my old website, I decided to go with a static website which allows me to host the site for free using Github pages. I used a static site generator called &lt;a href=&#34;https://jekyllrb.com/&#34; target=&#34;_blank&#34;&gt;Jekyll&lt;/a&gt;. However, I found it a bit time consuming to use. I wanted to spend more time focusing on the content of the website and less on the setup. So I did a little research on other static site generators that I can use and came across &lt;a href=&#34;https://gohugo.io/&#34; target=&#34;_blank&#34;&gt;Hugo&lt;/a&gt;. It seemed to have all the nice features that a static site generator should have. It works across all operatings systems, had a lot of free themes, was open source and most importantly was easy to set up. I was able to get a basic website generated in under two minutes by following their getting started tutorial. If you&amp;rsquo;re looking for a good static site generator, I highly recommend Hugo.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
