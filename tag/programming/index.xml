<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming | Ashwin Narayan</title><link>https://www.ashwinnarayan.com/tag/programming/</link><atom:link href="https://www.ashwinnarayan.com/tag/programming/index.xml" rel="self" type="application/rss+xml"/><description>programming</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2020 Ashwin Narayan</copyright><lastBuildDate>Sun, 06 Oct 2024 20:04:51 +0800</lastBuildDate><image><url>https://www.ashwinnarayan.com/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url><title>programming</title><link>https://www.ashwinnarayan.com/tag/programming/</link></image><item><title>Writing a small async runtime for Cortex-M micro-controllers with Rust</title><link>https://www.ashwinnarayan.com/post/embedded-async-with-rust/</link><pubDate>Sun, 06 Oct 2024 20:04:51 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/embedded-async-with-rust/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>I&amp;rsquo;ve been working with Rust on microcontrollers for a while now, and I&amp;rsquo;ve been using the excellent embassy crate for async programming. However, I recently started using a processor for which embassy does not have Hardware Abstraction Layer (HAL) support, and I wanted to experiment with building my own async runtime. This was also a great opportunity to learn more about the processor and understand the implementation details of async/await in Rust.&lt;/p>
&lt;p>In this article, we&amp;rsquo;ll create an async runtime for ARM Cortex-M microcontrollers. We&amp;rsquo;ll build on Philipp Oppermann&amp;rsquo;s work for x86 bare-metal systems here and adapt the approach for Cortex-M, which presents unique challenges like limited memory and often lacking a Memory Management Unit (MMU). These constraints require different design choices for async primitives, executors, and interrupt handling.&lt;/p>
&lt;p>Note that this is an experimental project focused on learning and exploration. It is not production-ready, but it serves as a good starting point for building your own async runtime for embedded systems. If you&amp;rsquo;re looking for mature libraries for running real-time code on embedded systems, consider using
&lt;a href="https://embassy.dev" target="_blank" rel="noopener">embassy&lt;/a> or
&lt;a href="https://rtic.rs" target="_blank" rel="noopener">rtic&lt;/a>.&lt;/p>
&lt;p>We will cover:&lt;/p>
&lt;ol>
&lt;li>Building a lightweight executor for embedded systems&lt;/li>
&lt;li>Implementing tasks in an async context&lt;/li>
&lt;li>Utilizing power-saving features to sleep the microcontroller when no tasks are active&lt;/li>
&lt;/ol>
&lt;p>By the end of this article, you&amp;rsquo;ll understand the basics of creating a custom async runtime and how it can be adapted to a resource-constrained environment like Cortex-M microcontrollers.&lt;/p>
&lt;h2 id="why-build-your-own-async-runtime">Why Build Your Own Async Runtime?&lt;/h2>
&lt;p>Building an async runtime from scratch is not just a fun exercise but a useful way to understand how embedded systems handle concurrent tasks. This is particularly important for real-time systems that need to manage limited resources, such as processing power and memory. You&amp;rsquo;ll also be forced to become familiar with the inner workings the underlying hardware peripherals on the microcontroller and how they interact with the runtime. In a world where abstractions are stacked liberally and the typical developer is separated from the hardware by multiple layers of abstraction, this exercise can be a refreshing change of pace.&lt;/p>
&lt;p>With existing libraries like Embassy, you can quickly get started with async programming on supported hardware. However, there might be scenarios where support for specific hardware is not available, or you need more control over how tasks are managed. This article aims to bridge that gap by helping you understand what it takes to write a custom runtime for such cases.&lt;/p>
&lt;h2 id="what-is-async-programming">What is Async Programming?&lt;/h2>
&lt;p>In Rust, async/await allows you to write asynchronous code that looks very similar to synchronous code. It allows you to write code that can pause and resume execution without blocking the entire system, which is particularly useful for handling tasks like I/O operations, waiting for timers, or running multiple concurrent tasks.&lt;/p>
&lt;p>The async model in Rust uses cooperative multitasking, where tasks yield control back to the executor when they are waiting for something to happen. This is different from preemptive multitasking, where an operating system controls task switching. Cooperative multitasking has the advantage of being predictable and having lower overhead, but it requires each task to explicitly yield control and be well-behaved.&lt;/p>
&lt;p>For embedded systems, cooperative multitasking often works well because it keeps the system simple and avoids the overhead of complex task switching, which is critical when working with constrained environments like microcontrollers.&lt;/p>
&lt;h2 id="how-async-works-in-rust">How Async Works in Rust&lt;/h2>
&lt;p>In Rust, async functions implement the Future trait. Futures can be polled using the poll() method. If a future is ready to produce a value, it returns Poll::Ready(T); otherwise, it returns Poll::Pending. The executor is responsible for polling these futures and managing the lifecycle of tasks.&lt;/p>
&lt;p>The executor works by polling each task until it completes. It acts as the &amp;ldquo;runtime&amp;rdquo; that runs the tasks concurrently and keeps them progressing. For more details on how this works, I recommend checking out
&lt;a href="https://os.phil-opp.com/async-await" target="_blank" rel="noopener">Phil Oppermann&amp;rsquo;s blog&lt;/a>.&lt;/p>
&lt;h2 id="async-execution-workflow">Async Execution Workflow&lt;/h2>
&lt;p>Below is a visual representation of how an async executor manages tasks and keeps polling them until completion.&lt;/p>
&lt;pre>&lt;code class="language-mermaid">graph TD
subgraph Executor
A[Task Queue] --&amp;gt; B[Task Polling]
end
subgraph Task
D[Future] --&amp;gt; E[Poll Function]
end
A --&amp;gt; F[Task Scheduler]
F --&amp;gt; E
E --&amp;gt; G{Poll Result}
G --&amp;gt;|Pending| F
G --&amp;gt;|Ready| H[Complete Task]
M[Sleep if Idle] --&amp;gt; F
&lt;/code>&lt;/pre>
&lt;p>This diagram shows how the executor maintains a queue of tasks, polls them to determine their state, and schedules them accordingly. If there are no tasks to execute, the executor can put the processor to sleep to save power.&lt;/p>
&lt;h2 id="defining-a-task">Defining a Task&lt;/h2>
&lt;p>Each task in our runtime is represented as a &lt;code>Future&lt;/code> pinned in memory, ensuring it can be polled without being moved. This is crucial because futures created by &lt;code>async&lt;/code>/&lt;code>await&lt;/code> may be self-referential, and moving them in memory would invalidate references to their internal fields.&lt;/p>
&lt;p>Embedded environments typically don&amp;rsquo;t have access to standard memory allocators, so we need to initialize a custom heap allocator. We&amp;rsquo;ll use the &lt;code>embedded_alloc&lt;/code> crate, which is designed for embedded systems. Below is the implementation of our task and how it uses atomic counters for task IDs.&lt;/p>
&lt;pre>&lt;code class="language-rust">// Import the 'alloc' crate, which provides memory allocation utilities.
// Necessary for dynamic memory allocation in a no_std environment.
extern crate alloc;
// Importing 'Box' from the 'alloc' crate. Box is a smart pointer for heap-allocated memory.
use alloc::boxed::Box;
// Importing 'addr_of_mut' from core::ptr to get the mutable pointer to the heap memory.
use core::ptr::addr_of_mut;
// Importing 'AtomicU32' and 'Ordering' to manage atomic operations in a multi-threaded or interrupt context.
use core::sync::atomic::{AtomicU32, Ordering};
// Importing essential types for async and future handling from core: Future, Pin, Context, and Poll.
use core::{
future::Future,
pin::Pin,
task::{Context, Poll},
};
// Importing LlffHeap as Heap from 'embedded_alloc' crate, which provides a memory allocator suitable for embedded systems.
use embedded_alloc::LlffHeap as Heap;
// Define a global allocator for heap memory. We use a static instance of Heap here.
#[global_allocator]
static HEAP: Heap = Heap::empty(); // The heap is initially empty and needs to be initialized.
/// Initialize the heap.
pub fn init_heap() {
use core::mem::MaybeUninit; // Use 'MaybeUninit' to represent uninitialized memory safely.
const HEAP_SIZE: usize = 1024; // Define the size of the heap in bytes.
// Allocate an uninitialized array of bytes (of type MaybeUninit&amp;lt;u8&amp;gt;), which will serve as the heap.
static mut HEAP_MEM: [MaybeUninit&amp;lt;u8&amp;gt;; HEAP_SIZE] = [MaybeUninit::uninit(); HEAP_SIZE];
// Initialize the heap using the starting address and size of the memory array. 'unsafe' is required
// because we are using raw pointers and modifying static mutable data.
unsafe { HEAP.init(addr_of_mut!(HEAP_MEM) as usize, HEAP_SIZE) }
}
/// Task ID type. We use a 32-bit unsigned integer to represent a task ID.
/// Cortex-M architecture is 32-bit, and it doesn't support atomic 64-bit integers.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
struct TaskId(u32); // TaskId is a wrapper around a 32-bit unsigned integer.
impl TaskId {
/// Generate a new unique task ID.
fn new() -&amp;gt; Self {
static NEXT_ID: AtomicU32 = AtomicU32::new(0); // Static AtomicU32 that stores the next available task ID.
TaskId(NEXT_ID.fetch_add(1, Ordering::Relaxed)) // Increment and return the current ID.
}
}
/// Base struct to represent a task.
pub struct Task {
/// A unique identifier for the task.
id: TaskId, // Each task has a unique TaskId.
/// The future representing the task. The Pin&amp;lt;Box&amp;lt;&amp;gt;&amp;gt; wrapper ensures that the
/// future is not moved in memory. The Output type of the future is (), indicating
/// that the future does not return a value - it just runs to completion.
future: Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output = ()&amp;gt;&amp;gt;&amp;gt;, // The 'Pin' ensures that the future is pinned in memory and cannot be moved.
}
impl Task {
/// Create a new task from a future.
pub fn new(future: impl Future&amp;lt;Output = ()&amp;gt; + 'static) -&amp;gt; Task {
Task {
id: TaskId::new(), // Assign a new unique TaskId to the task.
future: Box::pin(future), // Pin the future to ensure it is not moved in memory and store it in a Box.
}
}
/// Poll the task. This checks whether the future is ready to make progress or has completed.
/// 'poll' uses a mutable reference to the task's future and a context to manage async execution.
fn poll(&amp;amp;mut self, context: &amp;amp;mut Context) -&amp;gt; Poll&amp;lt;()&amp;gt; {
self.future.as_mut().poll(context) // Poll the pinned future and pass the provided Context.
}
}
// A module declaration for 'executor', the runtime that manages task execution.
pub mod executor;
&lt;/code>&lt;/pre>
&lt;p>In this implementation, &lt;code>TaskId&lt;/code> is used to uniquely identify each task, and we use a 32-bit atomic counter to generate these IDs. This approach avoids the overhead of locking and works well in a 32-bit environment like Cortex-M.&lt;/p>
&lt;h2 id="implementing-the-executor">Implementing the Executor&lt;/h2>
&lt;p>The executor is responsible for managing tasks and running them to completion. It uses a task queue to determine which tasks are ready to run, and a custom &lt;code>TaskWaker&lt;/code> to wake up tasks when they are ready to make progress.&lt;/p>
&lt;p>Below is an implementation of the executor that runs tasks in a loop, polling each until they are complete.&lt;/p>
&lt;pre>&lt;code class="language-rust">extern crate alloc;
use super::*;
use alloc::collections::{BTreeMap, VecDeque};
use alloc::sync::Arc;
use alloc::task::Wake;
use core::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};
use cortex_m::asm;
use crossbeam_queue::ArrayQueue;
// The custom waker struct for waking tasks.
struct TaskWaker {
task_id: TaskId, // Unique identifier for the task.
task_queue: Arc&amp;lt;ArrayQueue&amp;lt;TaskId&amp;gt;&amp;gt;, // Shared queue used to store task IDs ready to be executed.
}
impl TaskWaker {
// Create a new waker instance for a given task.
fn new(task_id: TaskId, task_queue: Arc&amp;lt;ArrayQueue&amp;lt;TaskId&amp;gt;&amp;gt;) -&amp;gt; Waker {
Waker::from(Arc::new(TaskWaker {
task_id,
task_queue,
}))
}
// Add the task to the task queue, making it ready to be polled again.
fn wake_task(&amp;amp;self) {
self.task_queue
.push(self.task_id)
.expect(&amp;quot;Task queue is full!&amp;quot;);
}
}
impl Wake for TaskWaker {
// Wakes the task by adding it back to the task queue.
fn wake(self: Arc&amp;lt;Self&amp;gt;) {
self.wake_task();
}
// Wake the task by reference, allowing it to be added to the task queue without consuming the waker.
fn wake_by_ref(self: &amp;amp;Arc&amp;lt;Self&amp;gt;) {
self.wake_task();
}
}
/// Task executor that runs tasks to completion.
pub struct Executor {
/// Map of tasks to be run, indexed by task ID.
tasks: BTreeMap&amp;lt;TaskId, Task&amp;gt;,
/// Queue holding task IDs that are ready to be executed.
task_queue: Arc&amp;lt;ArrayQueue&amp;lt;TaskId&amp;gt;&amp;gt;,
/// Cache for storing wakers for tasks that are currently running.
waker_cache: BTreeMap&amp;lt;TaskId, Waker&amp;gt;,
}
impl Executor {
/// Create a new executor with an empty task queue.
pub fn new&amp;lt;const N: usize&amp;gt;() -&amp;gt; Executor {
Executor {
tasks: BTreeMap::new(),
task_queue: Arc::new(ArrayQueue::new(N)), // Initialize task queue with a capacity of N.
waker_cache: BTreeMap::new(),
}
}
/// Add a new task to the executor.
pub fn spawn(&amp;amp;mut self, task: Task) {
let task_id = task.id;
if self.tasks.insert(task_id, task).is_some() {
panic!(&amp;quot;task with same ID already in tasks&amp;quot;);
}
self.task_queue.push(task_id).expect(&amp;quot;Task queue is full.&amp;quot;); // Add the task ID to the task queue.
}
/// Run all tasks that are ready to execute.
fn run_ready_tasks(&amp;amp;mut self) {
// Continuously pop task IDs from the task queue and run them.
while let Some(task_id) = self.task_queue.pop() {
// Retrieve the task using its task ID.
let task = match self.tasks.get_mut(&amp;amp;task_id) {
Some(task) =&amp;gt; task,
None =&amp;gt; continue, // If the task doesn't exist, skip it.
};
// Retrieve or create a waker for the task.
let waker = self
.waker_cache
.entry(task_id)
.or_insert_with(|| TaskWaker::new(task_id, self.task_queue.clone()));
// Create a new context from the waker.
let mut context = Context::from_waker(waker);
// Poll the task to determine if it is ready to make progress.
match task.poll(&amp;amp;mut context) {
Poll::Ready(()) =&amp;gt; {
// If the task is complete, remove it and its waker from the cache.
self.tasks.remove(&amp;amp;task_id);
self.waker_cache.remove(&amp;amp;task_id);
}
Poll::Pending =&amp;gt; {} // If the task is not complete, leave it in the task list.
}
}
}
/// Put the processor to sleep if there are no tasks to run.
fn sleep_if_idle(&amp;amp;self) {
cortex_m::interrupt::free(|_| {
// If the task queue is empty, put the processor to sleep.
if self.task_queue.is_empty() {
asm::wfi(); // Wait for interrupt to wake up the processor.
}
});
}
/// Run the executor to completion, continuously executing tasks until none are left.
pub fn run(&amp;amp;mut self) {
loop {
self.run_ready_tasks();
self.sleep_if_idle();
}
}
}
&lt;/code>&lt;/pre>
&lt;p>The Executor structure maintains a map of tasks, a task queue, and cached wakers for tasks that are currently running. The run method continuously runs tasks until none are left, and the &lt;code>sleep_if_idle&lt;/code> method puts the processor to sleep when there are no tasks to execute. As mentioned
&lt;a href="https://github.com/phil-opp/blog_os/discussions/1018#discussioncomment-863025" target="_blank" rel="noopener">here&lt;/a> the &lt;code>wfi&lt;/code> instruction can be used to wait for an event or interrupt.&lt;/p>
&lt;h2 id="putting-it-all-together">Putting it all together&lt;/h2>
&lt;p>Below is an example of how to put everything together to run a simple async task on a Cortex-M microcontroller.&lt;/p>
&lt;pre>&lt;code class="language-rust">#![no_std]
#![no_main]
use cortex_m_asyncrt::os::{self, executor, init_heap, Task};
use cortex_m_rt::entry;
use cortex_m_semihosting::{dbg, hprintln};
// use panic_probe as _;
use panic_semihosting as _;
#[entry]
fn main() -&amp;gt; ! {
init_heap();
hprintln!(&amp;quot;Hello, worlds!&amp;quot;);
// New executor that can run up to 32 tasks
let mut executor = executor::Executor:: new::&amp;lt;64&amp;gt;();
// Spawn a task
executor.spawn(Task::new(example_task()));
// Run the executor
executor.run();
// This code is unreachable because the executor.run() function runs tasks to completion.
loop {}
}
async fn example_task() {
// your code goes here
let r = example_fn().await;
hprintln!(&amp;quot;r = {}&amp;quot;, r);
}
async fn example_fn() -&amp;gt; u32 {
42
}
&lt;/code>&lt;/pre>
&lt;p>If you run this code on QEMU you should see the following output:&lt;/p>
&lt;pre>&lt;code class="language-shell">Timer with period zero, disabling
Hello, worlds!
r = 42
&lt;/code>&lt;/pre>
&lt;p>If you want to try this out yourself, you can use the &lt;code>cortex-m-asyncrt&lt;/code> crate on
&lt;a href="https://crates.io/crates/cortex-m-asyncrt" target="_blank" rel="noopener">crates.io&lt;/a>. Version 0.1.0 of the crate is exactly as described in this article.&lt;/p>
&lt;h2 id="real-world-use-cases-and-future-work">Real-World Use Cases and Future Work&lt;/h2>
&lt;p>This async runtime could be applied to scenarios where you need a lightweight scheduler for real-time tasks, such as sensor data collection, motor control, or communication handling in resource-constrained embedded systems.&lt;/p>
&lt;p>Future improvements could include adding task priority, enhancing the scheduler with time measurements for scheduling tasks at regular intervals and for asynchronously &lt;code>await&lt;/code>ing delays.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;a href="https://os.phil-opp.com/async-await" target="_blank" rel="noopener">Philipp Oppermann&amp;rsquo;s blog on async/await&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://embassy.dev" target="_blank" rel="noopener">embassy&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://rtic.rs" target="_blank" rel="noopener">rtic&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://crates.io/crates/cortex-m-asyncrt" target="_blank" rel="noopener">cortex-m-asyncrt crate&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Blinking LEDs with Rust</title><link>https://www.ashwinnarayan.com/post/embedded-rust-blinking-led/</link><pubDate>Thu, 02 May 2024 15:38:20 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/embedded-rust-blinking-led/</guid><description>&lt;p>Rust is a modern programming language focused on safety, speed, and concurrency. It&amp;rsquo;s a go-to for system-level tasks, offering strong guarantees against common bugs like null pointer dereferences. Embedded systems, with their resource constraints and real-time demands, could really benefit from more Rust. Rust&amp;rsquo;s zero-cost abstractions maintain performance while keeping code size small. Real-time requirements are met through precise hardware interaction, aided by Rust&amp;rsquo;s features like immutable variables and robust type systems. With cross-compilation capabilities and a growing library ecosystem, Rust has recently become (in my opinion) a viable choice for embedded development.&lt;/p>
&lt;p>Rust is also the first new programming language that I&amp;rsquo;ve learned since Haskell and I really like how it combines the best of functional programming with the best of systems programming. I&amp;rsquo;ve been playing around with Rust for a while now and I wanted to try my hand at embedded development with Rust. In this post, I&amp;rsquo;ll show you how to blink an LED on an STM32F407 Discovery board using Rust.&lt;/p>
&lt;h2 id="the-stm32f407-discovery-board">The STM32F407 Discovery Board&lt;/h2>
&lt;p>The
&lt;a href="https://www.st.com/en/evaluation-tools/stm32f4discovery.html" target="_blank" rel="noopener">STM32F407 Discovery&lt;/a> board is a development board based on the STM32F407VG microcontroller. The board uses an STM32F407 micro-controller and has plenty of LEDs, some push buttons, an accelerometer, a microphone and an audio DAC. Plenty of peripherals to play around with. The
&lt;a href="https://www.st.com/resource/en/user_manual/um1472-discovery-kit-with-stm32f407vg-mcu-stmicroelectronics.pdf" target="_blank" rel="noopener">user manual&lt;/a> has the pinouts and list of peripherals.&lt;/p>
&lt;h2 id="setting-up-rust-for-embedded-development">Setting Up Rust for Embedded Development&lt;/h2>
&lt;p>First follow the instructions from
&lt;a href="https://rustup.rs" target="_blank" rel="noopener">rustup.rs&lt;/a> to install rust.&lt;/p>
&lt;pre>&lt;code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
&lt;/code>&lt;/pre>
&lt;p>To compile rust for our micro-controller, we need to let it know what target to compile for. Microcontrollers like the STM32 use the thumb instruction set, which is a subset of the ARM instruction set. Rust has a target for the thumb instruction set, so we need to install it.&lt;/p>
&lt;pre>&lt;code class="language-bash">rustup target add thumbv7em-none-eabihf
&lt;/code>&lt;/pre>
&lt;p>Next, we need to create a new empty project using cargo.&lt;/p>
&lt;pre>&lt;code class="language-bash">cargo new --bin blinky
&lt;/code>&lt;/pre>
&lt;p>Cargo needs some more information to build for a microcontroller. So we need a &lt;code>.cargo/config.toml&lt;/code> file in the project directory with the following contents:&lt;/p>
&lt;pre>&lt;code class="language-toml">[target.'cfg(all(target_arch = &amp;quot;arm&amp;quot;, target_os = &amp;quot;none&amp;quot;))']
# replace STM32F407VG with your chip as listed in `probe-rs chip list`
runner = &amp;quot;probe-rs run --chip STM32F407VG&amp;quot;
[target.thumbv7em-none-eabihf]
rustflags = [&amp;quot;-C&amp;quot;, &amp;quot;link-arg=-Tlink.x&amp;quot;]
[build]
target = &amp;quot;thumbv7em-none-eabihf&amp;quot;
[env]
DEFMT_LOG = &amp;quot;trace&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Also useful are some tools that can be used to prepare the binary for flashing onto the microcontroller. We can install these tools using cargo.&lt;/p>
&lt;pre>&lt;code class="language-bash">cargo install cargo-binutils
rustup component add llvm-tools-preview
&lt;/code>&lt;/pre>
&lt;h2 id="libraries">Libraries&lt;/h2>
&lt;p>Rust has a lot of libraries already that support the hardware of the STM32, which makes things very convenient for us. Rust also has an excellent library called
&lt;a href="https://embassy.dev" target="_blank" rel="noopener">embassy&lt;/a> - a lightweight async/await runtime that is designed to work on embedded devices. It is built on top of the &lt;code>cortex-m&lt;/code> crate, which provides low-level access to the ARM Cortex-M processors. In traditional C++ based embedded development, you would use an embedded RTOS like FreeRTOS or MBED OS to manage tasks and interrupts. However, with embasst, you can use the async/await syntax to write concurrent code that is (in my opinion) much easier to reason about and debug.&lt;/p>
&lt;p>To use embassy, add the following dependencies to your &lt;code>Cargo.toml&lt;/code> file:&lt;/p>
&lt;pre>&lt;code class="language-toml">[package]
name = &amp;quot;stm32f407_tests&amp;quot;
authors = [&amp;quot;Ashwin Narayan &amp;lt; ashwinnarayan1994@gmail.com &amp;gt;&amp;quot;]
version = &amp;quot;0.1.0&amp;quot;
edition = &amp;quot;2021&amp;quot;
[[bin]]
name = &amp;quot;blinky&amp;quot;
path = &amp;quot;src/bin/blinky.rs&amp;quot;
test = false
bench = false
# Set up the release profile to optimize our binaries
[profile.release]
codegen-units = 1 # better optimizations
debug = true # symbols are nice and they don't increase the size on Flash
lto = true # better optimizations
opt-level = &amp;quot;s&amp;quot; # Optimize for size
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
embassy-stm32 = { version = &amp;quot;0.1.0&amp;quot;, features = [
&amp;quot;stm32f407vg&amp;quot;,
&amp;quot;unstable-pac&amp;quot;,
&amp;quot;memory-x&amp;quot;,
&amp;quot;time-driver-any&amp;quot;,
&amp;quot;exti&amp;quot;,
&amp;quot;chrono&amp;quot;,
] }
embassy-executor = { version = &amp;quot;0.5.0&amp;quot;, features = [
&amp;quot;integrated-timers&amp;quot;,
&amp;quot;arch-cortex-m&amp;quot;,
&amp;quot;executor-thread&amp;quot;,
] }
embassy-time = { version = &amp;quot;0.3.0&amp;quot; }
embassy-sync = { version = &amp;quot;0.5.0&amp;quot; }
cortex-m = { version = &amp;quot;0.7&amp;quot;, features = [&amp;quot;critical-section-single-core&amp;quot;] }
cortex-m-rt = &amp;quot;0.7&amp;quot;
panic-probe = { version = &amp;quot;0.3&amp;quot; }
&lt;/code>&lt;/pre>
&lt;p>We will then delete the &lt;code>src/main.rs&lt;/code> file and create a new file &lt;code>src/bin/blinky.rs&lt;/code> that will contain our code to blink our LEDs.&lt;/p>
&lt;h2 id="blinking-an-led">Blinking an LED&lt;/h2>
&lt;p>First, the code:&lt;/p>
&lt;pre>&lt;code class="language-rust">#![no_std]
#![no_main]
use embassy_executor::Spawner;
use embassy_stm32::gpio::{Level, Output, Speed};
use embassy_time::{Duration, Ticker};
use panic_probe as _;
fn clock_config() -&amp;gt; embassy_stm32::Config {
let mut config = embassy_stm32::Config::default();
// Configure to use the high speed internal oscillator (HSI).
config.rcc.hsi = true;
config
}
#[embassy_executor::main]
async fn main(_spawner: Spawner) {
// Initialize embassy
let peripherals = embassy_stm32::init(clock_config());
// Create a new output pin - PA9 is the green led on the Discovery board
let mut green_led = Output::new(peripherals.PA9, Level::High, Speed::VeryHigh);
let mut red_led = Output::new(peripherals.PD5, Level::High, Speed::VeryHigh);
let mut green_led2 = Output::new(peripherals.PD12, Level::High, Speed::VeryHigh);
let mut orange_led = Output::new(peripherals.PD13, Level::High, Speed::VeryHigh);
let mut red_led2 = Output::new(peripherals.PD14, Level::High, Speed::VeryHigh);
let mut blue_led = Output::new(peripherals.PD15, Level::High, Speed::VeryHigh);
// Create a new Ticker for the delay
let mut ticker = Ticker::every(Duration::from_millis(100));
loop {
// Wait for the ticker to expire
ticker.next().await;
// Toggle the leds
green_led.toggle();
red_led.toggle();
green_led2.toggle();
orange_led.toggle();
red_led2.toggle();
blue_led.toggle();
}
}
&lt;/code>&lt;/pre>
&lt;p>Now let&amp;rsquo;s go through the code step by step and understand what each part does.&lt;/p>
&lt;h3 id="no-standard-library-and-no-main">No Standard Library and No Main&lt;/h3>
&lt;pre>&lt;code class="language-rust">#![no_std]
#![no_main]
&lt;/code>&lt;/pre>
&lt;p>&lt;code>#![no_std]&lt;/code> tells the rust compiler that we are building a binary without the standard library and &lt;code>#![no_main]&lt;/code> tells the Rust compiler that this program does not use the conventional main function as its entry point. This is typical in embedded applications where the entry point needs to conform to specific requirements or where the startup is handled by the hardware or a framework.&lt;/p>
&lt;h3 id="importing-libraries">Importing Libraries&lt;/h3>
&lt;p>Next, the library imports.&lt;/p>
&lt;ul>
&lt;li>Spawner from embassy_executor is used to handle task spawning in an async environment.&lt;/li>
&lt;li>From embassy_stm32::gpio, we import Level, Output, and Speed to configure GPIO pins.&lt;/li>
&lt;li>Duration and Ticker from embassy_time are used to handle time-related functions like delays.&lt;/li>
&lt;li>panic_probe is a library used for better panic messages in embedded systems; the as _ means it&amp;rsquo;s used for its side effects (setting up panic handling) and not for its symbols.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust">use embassy_executor::Spawner;
use embassy_stm32::gpio::{Level, Output, Speed};
use embassy_time::{Duration, Ticker};
use panic_probe as _;
&lt;/code>&lt;/pre>
&lt;h3 id="clock-configuration">Clock Configuration&lt;/h3>
&lt;p>This function sets up the clock configuration for the STM32 microcontroller. It enables the High-Speed Internal oscillator (HSI) which is one of the clock sources that can drive the system clock.&lt;/p>
&lt;pre>&lt;code class="language-rust">fn clock_config() -&amp;gt; embassy_stm32::Config {
let mut config = embassy_stm32::Config::default();
config.rcc.hsi = true; // Configure to use the high speed internal oscillator (HSI).
config
}
&lt;/code>&lt;/pre>
&lt;h3 id="main-function">Main Function&lt;/h3>
&lt;p>The &lt;code>#[embassy_executor::main]&lt;/code> attribute macro marks this asynchronous function as the entry point of the program. The function takes a Spawner argument for potentially spawning new asynchronous tasks. It initializes the STM32 peripherals according to our configuration.&lt;/p>
&lt;pre>&lt;code class="language-rust">#[embassy_executor::main]
async fn main(_spawner: Spawner) {
let peripherals = embassy_stm32::init(clock_config());
&lt;/code>&lt;/pre>
&lt;h3 id="gpio-pins">GPIO Pins&lt;/h3>
&lt;p>Next, we set up our GPIO pins according to the discovery board&amp;rsquo;s pinout. We create Output instances for each LED pin, specifying the pin number, initial level, and speed. The pins are configured as outputs, and the initial level is set to High. The speed is set to VeryHigh, which is the fastest speed available. The speed specifies the maximum frequency at which the pin can be toggled.&lt;/p>
&lt;pre>&lt;code class="language-rust">let mut green_led = Output::new(peripherals.PA9, Level::High, Speed::VeryHigh);
...
let mut blue_led = Output::new(peripherals.PD15, Level::High, Speed::VeryHigh);
&lt;/code>&lt;/pre>
&lt;h3 id="ticker-for-delays">Ticker for Delays&lt;/h3>
&lt;pre>&lt;code class="language-rust">let mut ticker = Ticker::every(Duration::from_millis(100));
&lt;/code>&lt;/pre>
&lt;p>Ticker is an &lt;code>embassy_time&lt;/code> construct. The &lt;code>embassy_time&lt;/code> crate provides time-related functionality for embedded systems. The &lt;code>Ticker::every(Duration::from_millis(100))&lt;/code> creates a new Ticker that expires every 100 milliseconds.&lt;/p>
&lt;h3 id="the-main-loop">The Main Loop&lt;/h3>
&lt;pre>&lt;code class="language-rust">loop {
ticker.next().await;
green_led.toggle();
...
blue_led.toggle();
}
&lt;/code>&lt;/pre>
&lt;p>The main loop waits for the ticker to expire, toggles the LEDs, and repeats the process indefinitely. The &lt;code>ticker.next().await&lt;/code> suspends the task until the ticker expires, allowing the LEDs to blink at regular intervals. The &lt;code>toggle()&lt;/code> method changes the state of the LED from on to off and vice versa.&lt;/p>
&lt;h2 id="the-result">The Result&lt;/h2>
&lt;p>&lt;img src="blinky.gif" alt="Blinking LEDs">&lt;/p>
&lt;p>If you want to take a look at the code, the full repository is available at my
&lt;a href="https://github.com/RationalAsh/stm32f407-tests-rs" target="_blank" rel="noopener">github&lt;/a>.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust Programming Language&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://rust-embedded.github.io/book/" target="_blank" rel="noopener">Rust Embedded&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://embassy.dev" target="_blank" rel="noopener">Embassy&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://rustup.rs" target="_blank" rel="noopener">Rustup&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://www.st.com/en/evaluation-tools/stm32f4discovery.html" target="_blank" rel="noopener">STM32F407 Discovery&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://www.st.com/resource/en/user_manual/um1472-discovery-kit-with-stm32f407vg-mcu-stmicroelectronics.pdf" target="_blank" rel="noopener">STM32F407VG User Manual&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Reusable Forms in Swiftui</title><link>https://www.ashwinnarayan.com/post/reusable-forms-swiftui/</link><pubDate>Sun, 19 Mar 2023 13:52:25 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/reusable-forms-swiftui/</guid><description>&lt;p>I’ve been recently doing a lot of programming using Swift and I’m quite enjoying how intuitive it is to pick up. It also helps that SwiftUI generally produces good looking user interfaces with less effort than other things I’ve tried.&lt;/p>
&lt;p>Forms play a crucial role in creating interactive user interfaces for collecting and managing user input. Developing reusable form components in SwiftUI not only streamlines the development process but also ensures a consistent user experience throughout the app. By creating modular, reusable form components, developers can reduce code duplication, enhance maintainability, and simplify the process of updating or extending the functionality of their applications. In this article, we&amp;rsquo;ll explore the process of building a reusable login form component using SwiftUI.&lt;/p>
&lt;p>At the end of the article you should have a login form that looks like this:&lt;/p>
&lt;p>&lt;img src="screenshot.png" alt="screenshot-login">&lt;/p>
&lt;h2 id="first-the-code">First, the code&lt;/h2>
&lt;pre>&lt;code class="language-swift">import SwiftUI
struct LoginForm: View {
@State private var username: String = &amp;quot;&amp;quot;
@State private var password: String = &amp;quot;&amp;quot;
let onLoginButtonPress: ((String, String) -&amp;gt; Void)?
let onResetPasswordPress: (() -&amp;gt; Void)?
var body: some View {
VStack {
Text(&amp;quot;Login to App&amp;quot;)
.font(.title.bold())
.padding()
Spacer()
TextField(&amp;quot;Username&amp;quot;, text: $username)
.padding()
.autocapitalization(.none)
.disableAutocorrection(true)
.border(Color.gray, width: 1)
SecureField(&amp;quot;Password&amp;quot;, text: $password)
.padding()
.border(Color.gray, width: 1)
Button(action: {
onLoginButtonPress?(username, password)
}) {
Text(&amp;quot;Login&amp;quot;)
.padding()
.background(Color.blue)
.foregroundColor(.white)
.cornerRadius(5)
}
.padding()
Spacer()
Button {
onResetPasswordPress?()
} label: {
Text(&amp;quot;Forgot your password? Click here to reset it.&amp;quot;)
.font(.caption)
.padding()
}
}
.padding()
}
}
struct LoginForm_Previews: PreviewProvider {
static var previews: some View {
LoginForm(onLoginButtonPress: { userName, password in
print(&amp;quot;Login button tapped&amp;quot;)
print(&amp;quot;Username is \(userName), password is \(password)&amp;quot;)
},
onResetPasswordPress: {
print(&amp;quot;Reset password requested.&amp;quot;)
})
}
}
&lt;/code>&lt;/pre>
&lt;p>The code block above shows a login form where you can enter your username and password and has a button to login and a button to reset your password. Let’s take a look at how it works.&lt;/p>
&lt;h2 id="storing-username-and-password-states">Storing Username and Password States&lt;/h2>
&lt;p>We use private variables marked with &lt;code>@State&lt;/code> to hold the username and password variables. In SwiftUI, &lt;code>@State&lt;/code> is a property wrapper that manages the state of a value within a view. It provides local, mutable storage for simple values relevant to a specific view, allowing for mutability within an otherwise immutable view. &lt;code>@State&lt;/code> also allows child views or controls to read and write the property&amp;rsquo;s value using bindings, which is particularly useful for user input controls like TextField and Toggle. When a &lt;code>@State&lt;/code> property value changes, SwiftUI automatically re-renders the affected parts of the view hierarchy, ensuring that the view always reflects the current state of the data. It is important to use &lt;code>@State&lt;/code> only with value types, like structs, for proper change tracking, while other property wrappers like &lt;code>@ObservedObject&lt;/code> or &lt;code>@EnvironmentObject&lt;/code> are more suitable for reference types or complex data models.&lt;/p>
&lt;pre>&lt;code class="language-swift">@State private var username: String = &amp;quot;&amp;quot;
@State private var password: String = &amp;quot;&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>To bind these properties to the &lt;code>TextField&lt;/code> and &lt;code>SecureField&lt;/code>, respectively, you&amp;rsquo;ll use the &lt;code>$&lt;/code> symbol in front of the property names to create a binding:&lt;/p>
&lt;pre>&lt;code class="language-swift">TextField(&amp;quot;Username&amp;quot;, text: $username)
SecureField(&amp;quot;Password&amp;quot;, text: $password)
&lt;/code>&lt;/pre>
&lt;p>By binding &lt;code>@State&lt;/code> variables to &lt;code>TextField&lt;/code> and &lt;code>SecureField&lt;/code>, you ensure that your view always reflects the current state of the data, and changes made by the user in the input controls are automatically captured and stored in the corresponding &lt;code>@State&lt;/code> properties.&lt;/p>
&lt;h2 id="closures-for-form-actions">Closures for Form Actions&lt;/h2>
&lt;p>In the LoginForm code, &lt;code>onLoginButtonPress&lt;/code> and &lt;code>onResetPasswordPress&lt;/code> are closure parameters that are passed to the LoginForm view. These closures define custom behavior that will be executed when the login button and reset password button are pressed, respectively.&lt;/p>
&lt;ol>
&lt;li>&lt;code>onLoginButtonPress&lt;/code>: This closure takes two input parameters, a String for the username and a String for the password. It gets called when the user taps the &amp;ldquo;Login&amp;rdquo; button. You can define custom login functionality within this closure, such as authentication and navigation to the next screen.&lt;/li>
&lt;li>&lt;code>onResetPasswordPress&lt;/code>: This closure does not take any input parameters. It gets called when the user taps the &amp;ldquo;Forgot your password? Click here to reset it.&amp;rdquo; button. You can define custom reset password functionality within this closure, such as navigating to a password reset screen or showing a reset password prompt.&lt;/li>
&lt;/ol>
&lt;p>By using these closure parameters, you can create a more flexible and reusable LoginForm component, as the specific functionality for handling login and password reset actions can be defined outside the LoginForm view, making it adaptable to various use cases within your app.&lt;/p>
&lt;p>You may also have noticed that I’ve made the closure parameters optional by marking them with a &lt;code>?&lt;/code> symbol. By marking them as optional, you indicate that these closures can have a value (a function) or be &lt;code>nil&lt;/code>.&lt;/p>
&lt;p>I prefer and recommend optional closures because it allows you to use the LoginForm component in cases where you might not need to provide both closures. For example, you might want to display a LoginForm that only requires a login action and not the reset password functionality, or vice versa. In such cases, you can simply pass &lt;code>nil&lt;/code> for the closure you don&amp;rsquo;t need, without having to modify the LoginForm component itself.&lt;/p>
&lt;p>You might have scenarios where the behavior of the LoginForm component changes based on certain conditions. By making the closures optional, you can decide at runtime whether or not to provide a specific closure based on the current context or app state.&lt;/p>
&lt;p>To safely call these optional closures, use the optional chaining syntax with the &lt;code>?()&lt;/code> operator:&lt;/p>
&lt;pre>&lt;code class="language-swift">onLoginButtonPress?(username, password)
onResetPasswordPress?()
&lt;/code>&lt;/pre>
&lt;p>This syntax ensures that the closure is only called if it has a non-nil value; otherwise, nothing happens, and the app continues to function without any issues.&lt;/p>
&lt;h2 id="using-the-form-component-in-another-view">Using the Form Component in Another View&lt;/h2>
&lt;p>Here’s how you’d use this form component in the main ContentView of your app as an example.&lt;/p>
&lt;pre>&lt;code class="language-swift">import SwiftUI
struct ContentView: View {
var body: some View {
NavigationView {
LoginForm(onLoginButtonPress: { username, password in
// Implement your custom login functionality here
print(&amp;quot;Login button tapped&amp;quot;)
print(&amp;quot;Username: \(username), Password: \(password)&amp;quot;)
// For example, you might perform authentication and navigate to the next screen
}, onResetPasswordPress: {
// Implement your custom reset password functionality here
print(&amp;quot;Reset password requested.&amp;quot;)
// For example, you might navigate to a password reset screen or show a reset password prompt
})
.navigationBarTitle(&amp;quot;Your App&amp;quot;, displayMode: .large)
}
}
}
&lt;/code>&lt;/pre>
&lt;p>For &lt;code>onLoginButtonPress&lt;/code>, we print the username and password when the login button is tapped. In a real-world scenario, you&amp;rsquo;d likely perform authentication here and navigate to the next screen upon successful login.&lt;/p>
&lt;p>For &lt;code>onResetPasswordPress&lt;/code>, we print a message indicating that a password reset has been requested. In practice, you might navigate to a password reset screen, show a password reset prompt, or perform any other relevant action.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>In this article, we explored the creation of a reusable LoginForm component using SwiftUI. We learned about using &lt;code>@State&lt;/code> for local, mutable storage and two-way data binding with user interface controls, such as &lt;code>TextField&lt;/code> and &lt;code>SecureField&lt;/code>. We also discussed the flexibility and adaptability of the LoginForm component through optional closure parameters for handling login and password reset actions. SwiftUI&amp;rsquo;s declarative approach and powerful features, such as property wrappers and bindings, make it easy and efficient to build modular and reusable components for user interfaces. As you continue to delve into SwiftUI, you&amp;rsquo;ll find that it greatly simplifies app development and promotes consistent user experiences across your applications. Keep exploring and expanding your SwiftUI knowledge, and you&amp;rsquo;ll be well-equipped to create fantastic apps that delight your users.&lt;/p></description></item><item><title>Haskell Folds Illustrated</title><link>https://www.ashwinnarayan.com/post/a-study-on-haskell-folds/</link><pubDate>Sat, 01 Jan 2022 18:54:25 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/a-study-on-haskell-folds/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Now that I&amp;rsquo;ve submitted my PhD thesis for examination (finally!) I can spend some time fiddling around with things that are unrelated to it. After a hiatus of several months I&amp;rsquo;m finally back to playing with Haskell.&lt;/p>
&lt;p>One of the things that make Haskell notoriously hard and non-intuitive to learn is the idea of functions that act on other functions (higher order functions). Folds were the first thing that really made things fit together in my mind and helped me understand the strengths of functional programming and why people rave about elegance in haskell.&lt;/p>
&lt;p>Haskell has two types of folds: the left fold and the right fold with slightly different function signatures. Folds take a function that takes two arguments and returns a third &lt;code>(a -&amp;gt; b -&amp;gt; a)&lt;/code>, a value that can be considered a &amp;ldquo;seed&amp;rdquo; value, and a list. For the right fold, the seed has to be of the same type as the second argument of the function and the list elements have to have the same type as the first argument of the function. For the left fold, this is reversed. The seed has to be of the same type as the first argument to the function and the list elements have to be of the same type as the first argument of the function.&lt;/p>
&lt;pre>&lt;code class="language-hs">foldl :: (a -&amp;gt; b -&amp;gt; a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; a
foldr :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; b
&lt;/code>&lt;/pre>
&lt;p>Folds work like knocking down an arrangement of dominoes. It takes the seed value and the first element in the list and applies the function you have it. Then it repeatedly applies the function to the result and the next item in the list until all items in the list are consumed.&lt;/p>
&lt;h2 id="the-left-fold---illustrated">The Left Fold - Illustrated&lt;/h2>
&lt;pre>&lt;code class="language-mermaid">graph TD
BN[&amp;quot;B[N]&amp;quot;] --- FN
FN[fun :: b -&amp;gt; a -&amp;gt; b] -.- |&amp;quot;B[N-1]&amp;quot;|F2
FN --- AN[&amp;quot;A[N]&amp;quot;]
F2[fun :: b -&amp;gt; a -&amp;gt; b] --- |&amp;quot;B[1]&amp;quot;|F1
F2 --- A1[&amp;quot;A[1]&amp;quot;]
F1 --- S[&amp;quot;B[0]&amp;quot;]
F1[fun :: b -&amp;gt; a -&amp;gt; b] --- A0[&amp;quot;A[0]&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h2 id="the-right-fold---illustrated">The Right Fold - Illustrated&lt;/h2>
&lt;pre>&lt;code class="language-mermaid">graph TD
BN[&amp;quot;B[N]&amp;quot;] --- FN
FN[fun :: b -&amp;gt; a -&amp;gt; b] -.- |&amp;quot;B[N-1]&amp;quot;|F2
FN --- AN[&amp;quot;A[0]&amp;quot;]
F2[fun :: b -&amp;gt; a -&amp;gt; b] --- |&amp;quot;B[1]&amp;quot;|F1
F2 --- A1[&amp;quot;A[N-1]&amp;quot;]
F1 --- S[&amp;quot;B[0]&amp;quot;]
F1[fun :: b -&amp;gt; a -&amp;gt; b] --- A0[&amp;quot;A[N]&amp;quot;]
&lt;/code>&lt;/pre>
&lt;h2 id="applications">Applications&lt;/h2>
&lt;h3 id="summing-lists">Summing lists&lt;/h3>
&lt;p>A standard illustrative example is how a fold can be used to sum a list.&lt;/p>
&lt;p>Following the diagram, &lt;code>foldl (+) 0 [1, 2, 3, 4, 5]&lt;/code> would evaluate as 15. The fold function applies the &lt;code>(+)&lt;/code> operator to 0 and the 1 (the first element). Then apply &lt;code>(+)&lt;/code> to the result and the second element in the list and so on until we get the final result.&lt;/p>
&lt;h3 id="integration">Integration&lt;/h3>
&lt;p>A neat extension to summing lists is numerical integration. The simplest integral of an signal $x[t]$ (represnted by a list of values) with a sampling time $\Delta T$ can be expressed very simply as a fold (combined with a map).&lt;/p>
&lt;p>The equation&lt;/p>
&lt;p>$$ S = \sum_{i=0}^{N} x[i] \cdot \Delta T $$&lt;/p>
&lt;p>Turns into&lt;/p>
&lt;pre>&lt;code class="language-hs">simpleIntegral :: Double -&amp;gt; [Double] -&amp;gt; Double
simpleIntegral dT fvals = foldl1 (+) (map (*dT) fvals)
&lt;/code>&lt;/pre>
&lt;p>Here, &lt;code>foldl1&lt;/code> is a version of fold that takes the first element of the list as the seed.&lt;/p>
&lt;h3 id="scans-and-filtering">Scans and Filtering&lt;/h3>
&lt;p>From the illustrations of the left and right folds you can see that the folds produce a set of intermediate results that get fed back into the function. When having the intermediate results are useful, we have &lt;code>scan&lt;/code>. &lt;code>scan&lt;/code> is a fold that returns the intermediate results as a list rather than just the final result. This is useful in a lot of filtering operations; for instance to calculate the exponential moving average of stock prices.&lt;/p>
&lt;p>$$\begin{equation*}
S_t=\begin{cases}
Y_1 \quad &amp;amp;\text{if} , t = 0 \\
\alpha Y_{t} + (1-\alpha) S_{t-1} &amp;amp;\text{if} , t \gt 0 \\
\end{cases}
\end{equation*}$$&lt;/p>
&lt;p>The EMA equation can be implemented as:&lt;/p>
&lt;pre>&lt;code class="language-hs">ema :: Double -&amp;gt; [Double] -&amp;gt; [Double]
ema alpha vals = scanl1 (\prev curr -&amp;gt; alpha*curr + (1-alpha)*prev) vals
&lt;/code>&lt;/pre>
&lt;h2 id="summing-up">Summing Up&lt;/h2>
&lt;p>Interestingly, the Complementary Filter - often used to measure tilts using IMU sensors follow a very similar format and folds can be used to implement these type of filters. This is the biggest strength of using higher order functions. They capture commonly used patterns of calculations in a very general way. If you use a fold, the Haskell compiler will produce highly optimized code to run your calculation. If you were to use hand-written loops - especially in programming languages like C/C++ - you might write code that is inefficient or segfaults. Higher order functions are also very general. Haskell&amp;rsquo;s &lt;code>foldl&lt;/code> and &lt;code>foldr&lt;/code> works on any data type at all. This is the reason the type signatures for these functions don&amp;rsquo;t mention any concrete types. While I&amp;rsquo;ve only applied these functions to &lt;code>Double&lt;/code> data types, you can use this pattern on Strings, integers and on random custom defined data types. Higher order functions are also elegant. Rather than writing an ugly loop, I could write a one liner to do integration or complementary filtering. This is actually quite similar to how MATLAB scripting lets me express complicated operations like a matrix multiplication with a single operator.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ol>
&lt;li>
&lt;a href="http://learnyouahaskell.com/higher-order-functions" target="_blank" rel="noopener">Learn You a Haskell&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://www.cs.nott.ac.uk/~pszgmh/fold.pdf" target="_blank" rel="noopener">Hutton, Graham. &amp;ldquo;A tutorial on the universality and expressiveness of fold.&amp;rdquo; &lt;em>Journal of Functional Programming&lt;/em> 9.4 (1999): 355-372.&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://en.wikipedia.org/wiki/Moving_average" target="_blank" rel="noopener">Exponential Moving Average&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Building a Simple Telegram Bot Using Google Cloud Functions</title><link>https://www.ashwinnarayan.com/post/gcp-telegram-bot/</link><pubDate>Thu, 06 Jun 2019 13:59:15 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/gcp-telegram-bot/</guid><description>&lt;p>Many websites use bots to automate tasks and add useful (and sometimes harmful) functionality. For instance, there are reddit bots that can help you
&lt;a href="https://www.reddit.com/r/stabbot/comments/72irce/how_to_use_stabbot/" target="_blank" rel="noopener">stabilize shaky videos&lt;/a>,
&lt;a href="https://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/" target="_blank" rel="noopener">remind you of events&lt;/a> or even
&lt;a href="https://www.reddit.com/user/goodbot_badbot" target="_blank" rel="noopener">vote on the usefulness of other bots&lt;/a>.
&lt;a href="https://telegram.org/" target="_blank" rel="noopener">Telegram&lt;/a> - an instant messaging service similar to WhatsApp - lets you create and manage bots on their platform using their
&lt;a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">Bot API&lt;/a>. Bots on Telegram are officially identified and provide fun and useful services. Last month, while exploring Google Cloud Platform after getting some free student credits, I came across
&lt;a href="https://cloud.google.com/functions/" target="_blank" rel="noopener">Google Cloud Functions&lt;/a>. I realized that this hammer was perfect for the nail of setting up a simple Telegram bot.&lt;/p>
&lt;p>Many years ago, when Telegram&amp;rsquo;s bot API was still young, I tried to create a bot that would send you random pictures of aurorae if you asked. That bot and the server that it lived on crashed a long time ago. But the bot&amp;rsquo;s name and API key lived on, still registered with Telegram&amp;rsquo;s servers. I decided to necromance this bot from the dead and inject it with some fun new functionality. Being a lover space exploration and what it represents for humanity, I had the idea of giving the bot the ability to send you random images from NASA with informative descriptions as seen on the
&lt;a href="https://images.nasa.gov/" target="_blank" rel="noopener">NASA Image and Video Library&lt;/a>.&lt;/p>
&lt;h2 id="using-the-nasa-images-api">Using the NASA Images API&lt;/h2>
&lt;p>The first problem to solve is getting a random image from the NASA Image and Video Library. At first, I thought that I&amp;rsquo;d have to use a web-scraping python library to extract the images. But things turned out to be much easier. NASA has quite a few APIs that they&amp;rsquo;ve listed on
&lt;a href="https://api.nasa.gov/api.html#MarsPhotos" target="_blank" rel="noopener">this page&lt;/a>. Using their API, I can search through the images for any query I like and retrieve results in the form of JSON formatted data. The API uses &lt;code>HTTP GET&lt;/code> requests (
&lt;a href="https://www.w3schools.com/tags/ref_httpmethods.asp" target="_blank" rel="noopener">more info here&lt;/a>). So for example, if I need to search for images related to planets using the API, I would open the URL:
&lt;a href="https://images-api.nasa.gov/search?q=planet" target="_blank" rel="noopener">https://images-api.nasa.gov/search?q=planet&lt;/a>.&lt;/p>
&lt;p>There&amp;rsquo;s one extra step here. If you click on the api link above and examine the results, you&amp;rsquo;ll notice that it does not return all the results of a search at once. Instead, it gives you the first 100 results and gives you the option of getting more using the &amp;lsquo;page&amp;rsquo; parameter in the web request. So if I want to access the results from the 5th page of a search, I&amp;rsquo;d use the URL:
&lt;a href="https://images-api.nasa.gov/search?q=planet&amp;amp;page=5" target="_blank" rel="noopener">https://images-api.nasa.gov/search?q=planet&amp;amp;page=5&lt;/a>.&lt;/p>
&lt;p>So, to select a random result, I need to select a number between 1 and the total number of results and use modular arithmetic to figure out which page to get the result from. I encapsulated this logic in a single function that returns the URL and caption of a random result given a search query.&lt;/p>
&lt;pre>&lt;code class="language-py">import urllib.parse
import urllib.request
import json
import random
import math
import traceback
def get_random_nasa_image(search_term='planet'):
&amp;quot;&amp;quot;&amp;quot;
Fetch a random image from the NASA media library.
&amp;quot;&amp;quot;&amp;quot;
try:
# The API URL
nasa_img_url = &amp;quot;https://images-api.nasa.gov/search&amp;quot;
# Setup the search data
send_data = {}
send_data['q'] = search_term
send_data['media_type'] = 'image'
# Encode the url
url_values = urllib.parse.urlencode(send_data)
url = nasa_img_url + '?' + url_values
data = urllib.request.urlopen(url)
json_data = json.loads(data.read().decode('utf-8'))
num_results = json_data['collection']['metadata']['total_hits']
result_to_use = random.choice([i for i in range(num_results)])
page_num = math.ceil(result_to_use/100.0)
result_num_in_page = result_to_use%100
if page_num != 1:
# Do another request
send_data['page'] = page_num
url_values = urllib.parse.urlencode(send_data)
url = nasa_img_url + '?' + url_values
data = urllib.request.urlopen(url)
json_data = json.loads(data.read().decode('utf-8'))
image_url = json_data['collection']['items'][result_num_in_page]['links'][0]['href']
image_caption = json_data['collection']['items'][result_num_in_page]['data'][0]['description']
image_title = json_data['collection']['items'][result_num_in_page]['data'][0]['title']
else:
image_url = json_data['collection']['items'][result_num_in_page]['links'][0]['href']
image_caption = json_data['collection']['items'][result_num_in_page]['data'][0]['title']
image_title = json_data['collection']['items'][result_num_in_page]['data'][0]['description']
return (image_url, image_title, image_caption)
except Exception as e:
traceback.print_exc()
err_url = 'https://upload.wikimedia.org/wikipedia/commons/3/3b/Gato_enervado_pola_presencia_dun_can.jpg'
err_caption = 'Uh-Oh. Something went wrong. Here\'s a picture of a cat instead.'
return (err_url, err_caption, json_data)
&lt;/code>&lt;/pre>
&lt;h2 id="sending-the-image-to-telegram">Sending the Image to Telegram&lt;/h2>
&lt;p>To make a Telegram Bot send an image to a user we need three pieces of information.&lt;/p>
&lt;ol>
&lt;li>&lt;em>The Chat ID&lt;/em> : The chat ID is like a serial number that uniquely identifies the chat between a bot and a user.&lt;/li>
&lt;li>&lt;em>The Photo&lt;/em> : There are a few different formats that telegram accepts the photo in. I chose the simplest option, a string with the URL to the photo.&lt;/li>
&lt;li>&lt;em>The Bot API Key&lt;/em> : This is a long random looking string that you get when you create a bot. See instructions
&lt;a href="https://core.telegram.org/bots#botfather" target="_blank" rel="noopener">here&lt;/a> to learn how to get your own.&lt;/li>
&lt;/ol>
&lt;p>The actual sending of the message is achieved by using more HTTP GET or POST requests. In this case I used the
&lt;a href="https://core.telegram.org/bots/api#sendphoto" target="_blank" rel="noopener">sendPhoto&lt;/a> function defined in the API. Again, I encapsulated the functionality to send the photo into a single function.&lt;/p>
&lt;pre>&lt;code class="language-py">def sendPhoto(chat_id, url, caption):
sendPhotoUrl = 'https://api.telegram.org/bot{your-api-key}/sendPhoto'
data = {}
data['chat_id'] = chat_id
data['photo'] = url
data['caption'] = caption
data = urllib.parse.urlencode(data)
data = data.encode('ascii') # data should be bytes
req = urllib.request.Request(sendPhotoUrl, data)
with urllib.request.urlopen(req, timeout=10) as response:
the_page = response.read()
return the_page
&lt;/code>&lt;/pre>
&lt;h2 id="setting-up-a-google-cloud-function">Setting Up a Google Cloud Function&lt;/h2>
&lt;p>Google Cloud Functions allow you to execute a custom block of code when triggered by some kind of event - like it being a certain time of the day. Apart from Google, companies like Amazon and Microsoft also have their own versions of cloud functions.&lt;/p>
&lt;p>Since my application logic was fairly simple, I opted to setup my cloud function from their web interface by following the instructions on this
&lt;a href="https://cloud.google.com/functions/docs/quickstart-console" target="_blank" rel="noopener">page&lt;/a>. I kept all the default settings and opted to use Python 3.7 since that&amp;rsquo;s the programming language that I&amp;rsquo;m the most familiar with. The &amp;lsquo;hello_world&amp;rsquo; function that they have setup is the function that will be called when the service is triggered.&lt;/p>
&lt;p>Inside the function, I need to implement some very simple logic:&lt;/p>
&lt;ol>
&lt;li>Extract the Chat ID from the incoming message.&lt;/li>
&lt;li>Get a random NASA photo.&lt;/li>
&lt;li>Send the photo (along with its caption) to the incoming message&amp;rsquo;s Chat ID&lt;/li>
&lt;li>Return an HTTP OK response.&lt;/li>
&lt;/ol>
&lt;p>Here&amp;rsquo;s my code for the main function that&amp;rsquo;s called when an event is triggered. I&amp;rsquo;ve added some exception handling to the main logic as well.&lt;/p>
&lt;pre>&lt;code class="language-py">def hello_world(request):
&amp;quot;&amp;quot;&amp;quot;Responds to any HTTP request.
Args:
request (flask.Request): HTTP request object.
Returns:
The response text or any set of values that can be turned into a
Response object using
`make_response &amp;lt;http://flask.pocoo.org/docs/1.0/api/#flask.Flask.make_response&amp;gt;`.
&amp;quot;&amp;quot;&amp;quot;
request_json = request.get_json()
doneFlag = False
try_counter = 0
try_max = 5
while not doneFlag:
try:
# Send back a random nasa photo
photo, title, caption = get_random_nasa_image()
print(photo)
sendPhoto(request_json['message']['chat']['id'],
photo, caption)
doneFlag = True
except:
print(&amp;quot;Something Went Wrong. Trying again!&amp;quot;)
try_counter = try_counter + 1
if try_counter &amp;gt; 5:
doneFlag = True
traceback.print_exc()
sendPhoto(request_json['message']['chat']['id'],
'https://upload.wikimedia.org/wikipedia/commons/3/3b/Gato_enervado_pola_presencia_dun_can.jpg',
'I\'m Sorry, something went wrong. Here\'s a cat picture instead. :P')
else:
pass
print(request_json)
return f'HTTP/1.0 200 OK'
&lt;/code>&lt;/pre>
&lt;h2 id="connecting-the-telegram-bot-to-the-cloud-function">Connecting the Telegram Bot to the Cloud Function.&lt;/h2>
&lt;p>The final step is to connect the Telegram Bot to the Cloud Function so that the function is triggered every time the bot receives a message from someone. The Telegram API has a function for just that.
&lt;a href="https://core.telegram.org/bots/api#setwebhook" target="_blank" rel="noopener">setWebhook&lt;/a> allows you to set a URL that gets called every time the bot gets a new message. All the message data is passed on in JSON format. To connect your bot to the cloud function that you just created, you need to set the webhook to the URL specified in the &amp;lsquo;Trigger&amp;rsquo; tab of the function details page.&lt;/p>
&lt;p>&lt;img src="https://www.ashwinnarayan.com/img/gcf_trigger.JPG" alt="gcf_image">&lt;/p>
&lt;h2 id="demo">Demo&lt;/h2>
&lt;p>And we&amp;rsquo;re done! If there are no errors in the code, your bot should be triggered every time it receives a message. Here&amp;rsquo;s a demo of my bot working:&lt;/p>
&lt;p>&lt;img src="https://www.ashwinnarayan.com/img/telegram_bot_demo.png" alt="demo_image">&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Successes like these are the reason that I sometimes revive old projects. In the years that passed between my two attempts, some technologies had become cheap enough that I could use it nearly for free. In my last attempt to build the bot, I used a custom VPS server (basically a linux server) to try and run the bot. This meant that in addition to the logic for the bot, I needed to figure out how to get the bot to run on the server reliably. I often had to go back and restart the server or the script because it had got itself into an unexpected state. For cloud functions, there is no state. Each event invokes a new call of the function and if there is an error, the next function call isn&amp;rsquo;t affected by it. I also don&amp;rsquo;t need to worry about reliability and uptime because Google manages the service. Building systems like these are a great way of learning more about the inner workings of the internet and I hope that others who want to build their own Telegram bots (or other web based things) can use this article as a starting point.&lt;/p></description></item><item><title>Learning Haskell Through Google Code Jam</title><link>https://www.ashwinnarayan.com/post/learning-haskell-google-code-jam/</link><pubDate>Sat, 13 Apr 2019 08:26:34 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/learning-haskell-google-code-jam/</guid><description>&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>Over the last year or so, I&amp;rsquo;ve been playing around with
&lt;a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">functional programming&lt;/a>. As the first few lines of the Wikipedia page suggest, functional programming is all about expressing a computation or algorithm as the composition of functions rather than using a state that changes over time. From what I&amp;rsquo;ve understood so far, functional programming is based on
&lt;a href="https://en.wikipedia.org/wiki/Lambda_calculus" target="_blank" rel="noopener">lambda calculus&lt;/a> which is an alternative but equivalent formulation of the famous Turing Machine that most modern computers are based on.&lt;/p>
&lt;p>Once you start reading up on functional programming, the language that is most often recommended is
&lt;a href="https://www.haskell.org/" target="_blank" rel="noopener">Haskell&lt;/a>. I got interested in functional programming and Haskell in the first place because I was attracted by its more mathematical appearance. A lot of the code that I looked at seemed to express ideas much more clearly and (in my opinion) more beautifully. However, Learning Haskell was not easy at all. As someone who&amp;rsquo;s been programming using imperative languages all my life, I found it unusually difficult to think about solving problems using the style that Haskell (and functional programming) imposed. Near the beginning of my journey to learn the language, there were quite a lot of stops and restarts and many instances where I questioned whether it was even useful to learn the language. I found it so difficult to express ideas that were, in my head simple to express in a language like Python. I also found writing programs that required I/O quite difficult. However, the aforementioned clarity and beauty that I found in the way functional programming expressed ideas stuck with me and I kept coming back to it. after nearly a year, things fell into place and I started writing code that was actually useful (i.e. interacted with the world through I/O). I feel like I&amp;rsquo;m finally at a point where I can program well enough in the language that I can solve problems without struggling too much with I/O. So, when I got the email notifying me about this year&amp;rsquo;s Google Code Jam I thought I&amp;rsquo;d participate and try to use Haskell as much as possible!&lt;/p>
&lt;h2 id="google-code-jam">Google Code Jam&lt;/h2>
&lt;p>I&amp;rsquo;ve known about Google Code Jam for quite a while. I&amp;rsquo;ve even tried participating once before near the beginning of my undergraduate degree. Being a novice at the time, I did not even make it past the qualifying round. Since then I&amp;rsquo;ve been programming on a regular basis for nearly six years and it&amp;rsquo;s paid off. This time, I made it past the qualifying round quite comfortably. The main challenge before me was my use of a programming language that I hadn&amp;rsquo;t fully mastered yet. The added challlenge did make solving the problems a lot more fun however. Along the way, I was able to take advantage of some functional programming patterns and I thought that it might be valuable to write an article about how these patterns can be useful.&lt;/p>
&lt;h2 id="problem-1---foregone-solution">Problem 1 - Foregone Solution&lt;/h2>
&lt;p>To read the full problem description
&lt;a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/0000000000088231" target="_blank" rel="noopener">go here&lt;/a>.&lt;/p>
&lt;h3 id="summary-of-problem-statement">Summary of Problem Statement&lt;/h3>
&lt;p>The input for each testcase is a number N which when expressed in base 10 may or may not contain the digit 4. The goal is to split up the number N into 2 numbers A and B so that A + B = N and neither A nor B contain the digit 4.&lt;/p>
&lt;h3 id="analysis">Analysis&lt;/h3>
&lt;p>A brute force approach to the solution would search through all possible sums of two integers between 0 and N/2. Of course, this solution would scale as $O(N^2)$ and would not work with the larger test cases. Another thing to think about is that the hidden test cases can contain numbers between 1 and $10^{100}$. That number is beyond the range of usual integer data types. The problem can be solved quite easily by making the simple observation that you can split up all the digits that are 4 into 2 and 2 (or 3 and 1) and easily generate two numbers without even adding the two numbers to check if they sum up to N. For instance, if N is 9454 you can split it up into 9252 and 202. To do this you do not even need to convert the number into an integer data type. You can work with the string representation directly.&lt;/p>
&lt;h3 id="solution">Solution&lt;/h3>
&lt;p>I will read each test case number as a string and create two new numbers A and B. A will have all the digits 4 replaced with 2 and the remaining digits the same. B Will have all the digits 4 replaced with 2 and all the remaining digits replaced with 0. This pattern of replacing each member of an array with another one using information from only a single array element can be implemented using the higher order function &lt;code>map&lt;/code>. So, I defined two functions to calculate A and B.&lt;/p>
&lt;pre>&lt;code class="language-hs">getA :: [Char] -&amp;gt; [Char]
getA n = map (\x -&amp;gt; if x == '4' then '2' else '0') n
getB :: [Char] -&amp;gt; [Char]
getB n = map (\x -&amp;gt; if x == '4' then '2' else x) n
&lt;/code>&lt;/pre>
&lt;p>The rest of the solution is just I/O. You can see my full solution
&lt;a href="https://gist.github.com/RationalAsh/b92dfab3970e5d9ba2b4855afedf0d5c" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h2 id="problem-2-you-can-go-your-own-way">Problem 2: You Can Go Your Own Way&lt;/h2>
&lt;p>To read the full problem description
&lt;a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881da" target="_blank" rel="noopener">go here&lt;/a>.&lt;/p>
&lt;h3 id="summary-of-the-problem-statement">Summary of the Problem Statement&lt;/h3>
&lt;p>The goal is to get from the top right corner of an NxN grid to the bottom right corner using only South (Down) and East (Right) moves with the additional constraint that any segment of the path taken must not coincide (but can intersect at a single point) with another path that someone called Lydia took. The input is this path which is represented as a string containing uppercase &amp;ldquo;S&amp;rdquo; and &amp;ldquo;E&amp;rdquo; characters only.&lt;/p>
&lt;h3 id="analysis-1">Analysis&lt;/h3>
&lt;p>This problem looks more difficult to solve than it actually is. Once you know the trick, the code is quite simple. Here are some observations about the problem which helped me arrive at the solution.&lt;/p>
&lt;ul>
&lt;li>Observation 1: Number of &lt;code>S&lt;/code> moves and &lt;code>E&lt;/code> moves must be exactly equal to &lt;code>N-1&lt;/code> if you want to reach the bottom right corner. You can see this by thinking of each move as a vector. This implies that it might be possible to find the solution by just transforming the input string as it is read.&lt;/li>
&lt;li>Observation 2: If I have a function that only stays the same or decreases along the X-axis and intersects the point (0, 0), I can mirror the function along the line y=-x and the only places where the path intersects will be crossings. That means I can solve this by just doing the opposite of whatever Lydia does at each step.&lt;/li>
&lt;/ul>
&lt;p>This means that I can take Lydia&amp;rsquo;s path and reverse the action she took at each step like some dark mirror and I have my solution. Interestingly, this problem can also be solved using the &amp;ldquo;map&amp;rdquo; higher order function pattern in Haskell. The meat of my solution was implemented in two functions. One is the character (move) mapping function:&lt;/p>
&lt;pre>&lt;code class="language-hs">flipMove :: Char -&amp;gt; Char
flipMove c
| c == 'S' = 'E'
| c == 'E' = 'S'
| otherwise = c
&lt;/code>&lt;/pre>
&lt;p>And another is the function that transforms the input string into the output string.&lt;/p>
&lt;pre>&lt;code class="language-hs">solveCase :: String -&amp;gt; String
solveCase lydiasMoves = map flipMove lydiasMoves
&lt;/code>&lt;/pre>
&lt;p>As before, the rest of the code is just IO. My full solution is
&lt;a href="https://gist.github.com/RationalAsh/ba917a855dc63400245478ad4a03b1e5" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h2 id="problem-3-cryptopangrams">Problem 3: Cryptopangrams&lt;/h2>
&lt;p>This problem was a bit harder than the others. I spent a lot of time thinking about this one and solved it quite close to the end of the round. Some of my initial attempts failed because I didn&amp;rsquo;t consider all the edge cases. Read the full problem statement
&lt;a href="https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/000000000008830b" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h3 id="summary-of-problem-statement-1">Summary of Problem Statement&lt;/h3>
&lt;p>A string is &amp;ldquo;encoded&amp;rdquo; using the following procedure:&lt;/p>
&lt;ol>
&lt;li>26 prime numbers less than a number N are chosen.&lt;/li>
&lt;li>The numbers are sorted in increasing order and a character map is made from the numbers to the corresponding letter between A and Z.&lt;/li>
&lt;li>Each character in the sentence is replaced with the corresponding prime number (spaces are removed and ignored).&lt;/li>
&lt;li>The prime number at each position is replaced with the product of the number and the number corresponding to the next character in the sentence.&lt;/li>
&lt;/ol>
&lt;p>As an additional condition, the string is guaranteed to have all 26 characters occur at least once.&lt;/p>
&lt;p>For each case, as input, the maximum number N and the encoded sentence is given. The output should be the decoded sentence (without spaces).&lt;/p>
&lt;h3 id="analysis-2">Analysis&lt;/h3>
&lt;p>Let each sentence that is encoded be made of L characters. The set of primes that represent each of these characters can be represented by the sequence of numbers: $\{P_1, P_2, &amp;hellip; , P_L\}$. After the &amp;ldquo;encoding&amp;rdquo; procedure is carried out, the sequence will look like: $\{P_1\times P_2, P_2\times P_3, &amp;hellip; , P_{L-1}\times P_{L}\}$. The brute-force approach to solve this problem would involve trying to find the prime factors of each number in the sequence. However, if you look at the sequence above you can see that each number in the sequence except for the first one shares a common factor with the number before it! This means that if I find the common factors of the first two numbers in the sequence then I can factorize the entire sequence quite easily using the following procedure:&lt;/p>
&lt;ol>
&lt;li>Find the common factor between the first two numbers in the sequence.&lt;/li>
&lt;li>Divide the first number by this common factor to get the first factor.&lt;/li>
&lt;li>Second factor is the common factor.&lt;/li>
&lt;li>For all subsequent numbers, the first factor is the common factor with the previous number and the second factor is the number divided by the common factor.&lt;/li>
&lt;/ol>
&lt;h3 id="solution-1">Solution&lt;/h3>
&lt;p>So first, I wrote a function to find the greatest common divisor between two numbers. This function implements
&lt;a href="https://en.wikipedia.org/wiki/Euclidean_algorithm" target="_blank" rel="noopener">Euclid&amp;rsquo;s Algorithm&lt;/a> for find the greatest common divisor of two numbers:&lt;/p>
&lt;pre>&lt;code class="language-hs">commonFactor :: Integer -&amp;gt; Integer -&amp;gt; Integer
commonFactor a b
| remainder == 1 = 1
| remainder == 0 = if a &amp;gt; b then b else a
| otherwise = if a &amp;gt; b then commonFactor b remainder else commonFactor a remainder
where remainder = if a &amp;gt; b then snd (quotRem a b) else snd (quotRem b a)
&lt;/code>&lt;/pre>
&lt;p>In an imperative programming language we would loop through each character in the sequence to find the factors after setting up the loop by finding the common factor between the first two numbers. In Haskell the loop pattern for solving this particular problem is captured quite beautifully using the higher order function &lt;code>scanl&lt;/code>. The type signature for &lt;code>scanl&lt;/code> is &lt;code>(b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; [b]&lt;/code>. This means that scanl takes a function that takes a type &lt;code>a&lt;/code> and &lt;code>b&lt;/code> and returns a &lt;code>b&lt;/code>, a member of type &lt;code>b&lt;/code> and a list of type &lt;code>a&lt;/code> and returns a list of type &lt;code>b&lt;/code>.&lt;/p>
&lt;p>A &lt;code>scanl&lt;/code> is a higher order function that is a variant of a general pattern in computing called a &lt;code>fold&lt;/code>. To put it very simply, a fold takes a starting value (sometimes called a &lt;em>seed&lt;/em>), a function and a list and applies the function repeatedly in a specific way. If I write down the fold imperatively in a language like Python, it would look like this (f is the function that is applied recursively):&lt;/p>
&lt;pre>&lt;code class="language-python">seed = 0
for idx, elem in enumerate(lst):
if idx == 0:
result = f(seed, elem)
else:
result = f(result, elem)
&lt;/code>&lt;/pre>
&lt;p>A &lt;code>fold&lt;/code> will run this loop and return the final value of the &lt;code>result&lt;/code> in the computation. A &lt;code>scan&lt;/code> is just a fold that returns a list of the intermediate values at each iteration in the loop. Haskell has two &lt;code>scan&lt;/code> functions that work on lists: &lt;code>scanl&lt;/code> and &lt;code>scanr&lt;/code>. &lt;code>scanl&lt;/code> starts the iteration from the left side of the list and &lt;code>scanr&lt;/code> starts the iteration from the right side of the list.&lt;/p>
&lt;p>With this in mind, I wrote a scanl based function to factorize the list of input numbers.&lt;/p>
&lt;pre>&lt;code class="language-hs">factorizeCiphertext :: [Integer] -&amp;gt; [Integer]
factorizeCiphertext lst@(x1:x2:nums) = scanl (\n1 n2 -&amp;gt; n2 `div` n1) firstFactor lst
where firstFactor = x1 `div` (commonFactor x1 x2)
&lt;/code>&lt;/pre>
&lt;p>In my first attempt at solving the problem, I thought that this was the full solution. But I kept getting runtime errors once I uploaded the answer to the website. After thinking about the problem for a little bit I realized that I&amp;rsquo;d missed out on some edge cases. There are two ways in which this solution can fail.&lt;/p>
&lt;ol>
&lt;li>If there are consecutive numbers that are identical at the &lt;em>start&lt;/em> of the sequence. The common factor algorithm will return the number itself. Consecutive identical numbers can be caused by either repeated characters (&amp;ldquo;AAAAAA&amp;rdquo;) or by repeated alternating characters (&amp;ldquo;ABABABA&amp;rdquo;) in the plain text.&lt;/li>
&lt;li>If there are multiple but different consecutive numbers at the start of the sequence. For instance, if the cipher text starts like &lt;code>[9, 9, 9, 15, 15, 15, 35, 217]&lt;/code>.&lt;/li>
&lt;/ol>
&lt;p>Note that if repeated characters appear in the middle of the sequence, it does not matter since the procedure we use will divide this number by the previous factor anyway. To handle this edge case, we&amp;rsquo;ll need to extract any successive repeated numbers from the start of the sequence. So I wrote two functions to split the input list into two lists. One contains any repeated characters at the start of the list and the other is the rest of the list.&lt;/p>
&lt;pre>&lt;code class="language-hs">groupHead :: [Integer] -&amp;gt; [Integer]
groupHead (x:xs)
| x == (head xs) = [x] ++ (takeWhile (==x) xs) ++ groupHead (dropWhile (==x) xs)
| otherwise = []
groupTail :: [Integer] -&amp;gt; [Integer]
groupTail (x:xs)
| x == (head xs) = groupTail (dropWhile (==x) xs)
| otherwise = [x] ++ xs
&lt;/code>&lt;/pre>
&lt;p>For the rest of the list that does not have any initial repeating characters, the original &lt;code>factorizeCiphertext&lt;/code> function can be used to factorize the list. But how do we factorize the first part of the list? After a bit of thought I realized that if we factorize the first number in the second part of the list, it must have a common factor with the last number in the first part of the list. So now I can use this as the first factor to &lt;code>scan&lt;/code> the list from the right!&lt;/p>
&lt;p>So the final function that accounts for the edge cases is:&lt;/p>
&lt;pre>&lt;code class="language-hs">factorizeCiphertext4 :: [Integer] -&amp;gt; [Integer]
factorizeCiphertext4 (n:nums)
| isEdge = (scanr (\n1 n2 -&amp;gt; n1 `div` n2) (head factorTail) groupHeads) ++ (tail factorTail)
| otherwise = factorTail
where groupHeads = groupHead ([n] ++ nums)
isEdge = if (length groupHeads) &amp;gt; 0 then True else False
listToScan = groupTail ([n] ++ nums)
firstFactor = (head listToScan) `div` (commonFactor (head listToScan) (head $ tail listToScan))
factorTail = scanl (\f n -&amp;gt; n `div` f) firstFactor listToScan
&lt;/code>&lt;/pre>
&lt;p>You can view my full solution to the problem
&lt;a href="https://gist.github.com/RationalAsh/5edb735044535fcc98025383d8b648ad" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Haskell is a difficult language to learn, especially if you&amp;rsquo;ve only been exposed to imperative languages all your life. Rather than thinking in terms of discrete steps, you have to force yourself to think in terms of recursion and higher order patterns in the problem. However, if you stick with it for that initial amount of time that it takes to develop some basic proficiency, the results can be very rewarding. You can write some beautiful code in this language. After learning Haskell, I&amp;rsquo;ve also found myself using a functional approach to solve programming problems in other languages too! For instance, I&amp;rsquo;ve started using Python&amp;rsquo;s
&lt;a href="https://docs.python.org/3/library/itertools.html" target="_blank" rel="noopener">iterools&lt;/a> package much more often.&lt;/p>
&lt;p>However, usefulness wasn&amp;rsquo;t the main factor that motivated me to learn Haskell. For me it was more about the fun of solving puzzles in clever and aesthetically pleasing ways. Haskell is one of the few languages that puts some fun back into solving programming problems. I think it brings in some of the beauty and rigor traditionally associated with pure mathematics into a programming language. If you&amp;rsquo;re someone who enjoys programming puzzles for their own sake and finds beauty in clever solutions to puzzles, I highly recommend giving Haskell a go.&lt;/p></description></item><item><title>Hugo Web Development Workflow on Windows</title><link>https://www.ashwinnarayan.com/post/hugo-windows-workflow/</link><pubDate>Sun, 31 Dec 2017 11:41:31 +0530</pubDate><guid>https://www.ashwinnarayan.com/post/hugo-windows-workflow/</guid><description>&lt;p>As I mentioned in
&lt;a href="https://www.ashwinnarayan.com/post/welcome/">my first article on this blog&lt;/a>, I&amp;rsquo;m now using
&lt;a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo&lt;/a>, the static site generator to build my personal website. Due to the needs of my work environment (mostly because I need to use MS Word and certain MATLAB features on a regular basis), I&amp;rsquo;ve been primarily using Windows as my operating system for the past year or so. Having used Linux for a long time, I definitely missed the conveniences offered by shell scripting and other command line tools. However, while setting up a workflow in Windows for publishing content to my website I discovered that Windows&amp;rsquo; scripting tools are not all that bad. In fact, for anyone familiar with scripting from Linux, moving to Powershell isn&amp;rsquo;t that hard.&lt;/p>
&lt;h2 id="workflow">Workflow&lt;/h2>
&lt;p>A typical Hugo website development folder looks like this:
&lt;img src="https://www.ashwinnarayan.com/img/hugo_folders.jpg" alt="Folder Structure">&lt;/p>
&lt;p>I add new posts by creating new markown (.md) files in the &lt;code>post&lt;/code> folder. When the website is compiled using the &lt;code>hugo&lt;/code> command, the static website&amp;rsquo;s code is generated into the &lt;code>public&lt;/code> folder. The content inside this is what goes into the folder that is served by any webserver. Since I am hosting the website on Github Pages, I found it most convenient to set up a separate folder with a clone of the &lt;code>username.githug.io&lt;/code> repository. After article writing/editing is done, I can generate the website and copy the contents inside the &lt;code>public&lt;/code> folder to the repository folder to publish.&lt;/p>
&lt;p>When I am editing an article, I can preview content locally by using the &lt;code>hugo server --watch&lt;/code> command in the top level directory. This sets up a local webserver on &lt;code>localhost:1313&lt;/code> so that you can preview the website.&lt;/p>
&lt;p>To publish my website to Github pages after I&amp;rsquo;m done with development, I copy everything inside the &lt;code>public&lt;/code> folder into my local copy of the github repository and then commit all and push.&lt;/p>
&lt;h2 id="batch-script-automation">Batch Script Automation&lt;/h2>
&lt;p>Most of the the steps in the workflow can be automated away using batch scripts to save large amounts of time. I mean, who wants to spend time manually copying files and commiting after every small edit to the website? The &lt;code>build_on_laptop.bat&lt;/code> file in the top level directory handles everything. Diving into the source, I first delete everything inside the &lt;code>public&lt;/code> folder (Hugo does not automatically do this) and build a fresh version of the website.&lt;/p>
&lt;pre>&lt;code class="language-dos">rmdir /S /Q public
hugo
&lt;/code>&lt;/pre>
&lt;p>My Github pages repo has a few files that are not generated by Hugo. So I can&amp;rsquo;t just nuke the folder and delete everything. So I have a set of commands that delete all the Hugo generated files in the repository folder:&lt;/p>
&lt;pre>&lt;code class="language-dos">rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\categories&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\css&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\fonts&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\home&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\img&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\js&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\post&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\project&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\publication&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\publication_types&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\tags&amp;quot;
rmdir /S /Q &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\talk&amp;quot;
del &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\404.html&amp;quot;
del &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\index.html&amp;quot;
del &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\index.xml&amp;quot;
del &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\sitemap.xml&amp;quot;
del &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\site.webmanifest&amp;quot;
del &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io\styles.css&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Then comes the task of copying your updated website source into the folder. While it&amp;rsquo;s possible to use the &lt;code>cp&lt;/code> command, I found that the &lt;code>robocopy&lt;/code>
&lt;a href="https://technet.microsoft.com/en-us/library/cc733145.aspx?f=255&amp;amp;MSPPError=-2147217396" target="_blank" rel="noopener">command&lt;/a> is in general much better for copying files around in Windows.&lt;/p>
&lt;pre>&lt;code class="language-dos">robocopy public &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io&amp;quot; /E
&lt;/code>&lt;/pre>
&lt;p>Finally, I need to commit the new version of the website and push to github. This is also easily done:&lt;/p>
&lt;pre>&lt;code class="language-dos">cd &amp;quot;C:\Users\Ashwin Narayan\rationalash.github.io&amp;quot;
set /p commitmsg=&amp;quot;Enter a commit message: &amp;quot;
git add --all .
git commit -m &amp;quot;%commitmsg%&amp;quot;
git push origin master
&lt;/code>&lt;/pre>
&lt;p>So the end result is that when I run this script, it automatically deletes everything in the public folder and the repository folder, rebuilds and copies the new website over and then commits and pushes the new version to github to deploy the website.&lt;/p>
&lt;h2 id="even-more-automation-with-visual-studio-code">Even More Automation with Visual Studio Code&lt;/h2>
&lt;p>I can shave even more time off the workflow by using Visual Studio Code. VS Code has a really well made task management system. It&amp;rsquo;s also a natural choice since I do most of my markdown editing inside VS Code anyway. VS Code has a &lt;code>tasks.json&lt;/code> file where you can bind custom tasks/commands to key combinations. In this case, I just bound the default build task mapped to &lt;code>Ctrl&lt;/code>+&lt;code>Alt&lt;/code>+&lt;code>B&lt;/code> to the batch script. I also created a compose task which creates the local preview webserver.&lt;/p>
&lt;pre>&lt;code class="language-json">{
// See https://go.microsoft.com/fwlink/?LinkId=733558
// for the documentation about the tasks.json format
&amp;quot;version&amp;quot;: &amp;quot;0.1.0&amp;quot;,
&amp;quot;tasks&amp;quot;: [
{
&amp;quot;taskName&amp;quot;: &amp;quot;build&amp;quot;,
&amp;quot;command&amp;quot;: &amp;quot;build_on_laptop.bat&amp;quot;,
&amp;quot;isShellCommand&amp;quot;: true,
&amp;quot;showOutput&amp;quot;: &amp;quot;always&amp;quot;,
&amp;quot;echoCommand&amp;quot;: true
},
{
&amp;quot;taskName&amp;quot;: &amp;quot;compose&amp;quot;,
&amp;quot;command&amp;quot;: &amp;quot;hugo&amp;quot;,
&amp;quot;args&amp;quot;: [&amp;quot;server&amp;quot;, &amp;quot;--watch&amp;quot;],
&amp;quot;isShellCommand&amp;quot;: true,
&amp;quot;showOutput&amp;quot;: &amp;quot;always&amp;quot;,
&amp;quot;echoCommand&amp;quot;: true
}
]
}
&lt;/code>&lt;/pre>
&lt;p>With most of the steps automated, writing and publishing new articles don&amp;rsquo;t take that long compared to off the shelf solutions like Wordpress or Medium. It also comes with the advantage that you have full control over the website&amp;rsquo;s source code.&lt;/p></description></item><item><title>Bash Recipes for Doing Science!</title><link>https://www.ashwinnarayan.com/post/bash-recipes-for-science/</link><pubDate>Sun, 13 Aug 2017 19:30:14 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/bash-recipes-for-science/</guid><description>&lt;p>When prototyping programs that deal with lots of data on an Arduino and other embedded systems or even on full blown computers, it&amp;rsquo;s really useful to have a quick tool for plotting the output of the program. Initially, I used python for doing this. Python is a beautifully simple language and between Numpy, Scipy and Matplotlib, you can do pretty much anything you want with data; from doing simple plotting to running machine learning algorithms on the data. However, when all you want is to quickly plot a text file containing some data, breaking out a text editor to write a python script can get annoying especially if you do it many times a day.&lt;/p>
&lt;p>That was when I came across this interesting video from the computerphile YouTube channel.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/vT_J6xc-Az0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;p>It&amp;rsquo;s a fantastic interview with Brian Kernighan where he talks about his work on Unix and in particular then &lt;code>awk&lt;/code> command line tool. I&amp;rsquo;ve been using linux as my primary operating system for quite some time now and I do a lot of programming in it. So I am fairly comfortable with using the terminal for compiling and debugging code. But there was never a situation where I had to sit down and learn about all the terminal based utilities that were available. As I was watching Brian Kernighan describe &lt;code>awk&lt;/code> and how it works, I started to realize that I could really use this tool to my advantage when playing around with data. That was when I decided take a closer look at all the tools that were available on the linux terminal to see what I was missing out on.&lt;/p>
&lt;p>Over time I&amp;rsquo;ve developed a few &amp;ldquo;recipes&amp;rdquo; that are really useful to me and I thought I&amp;rsquo;d share some that I&amp;rsquo;ve found particularly useful.&lt;/p>
&lt;h2 id="1-log-and-monitor-a-serial-port">1. Log and monitor a serial port&lt;/h2>
&lt;p>Logging and monitoring serial ports is a really common thing to have to do - especially if you&amp;rsquo;re working with embedded systems like the Arduino. It&amp;rsquo;s a standard way of getting data off the microcontroller. Checking what&amp;rsquo;s being logged to the serial port is as simple as running:&lt;/p>
&lt;pre>&lt;code class="language-bash">cat /dev/ttyUSB0
&lt;/code>&lt;/pre>
&lt;p>Sometimes the command exits immediately or shows garbled output (due to the wrong baud rate). You can use &lt;code>stty&lt;/code> to change the serial port settings.&lt;/p>
&lt;pre>&lt;code class="language-bash">stty -F /dev/ttyUSB0 115200 min 1
&lt;/code>&lt;/pre>
&lt;p>I can also log the data from the serial port conveniently to a text file,&lt;/p>
&lt;pre>&lt;code class="language-bash">cat /dev/ttyUSB0 &amp;gt; logfilename.txt
&lt;/code>&lt;/pre>
&lt;h2 id="2-log-and-monitor-network-ports">2. Log and monitor network ports&lt;/h2>
&lt;p>One of the ways to get data off an Arduino is using an XBee device to wirelessly transmit it. I&amp;rsquo;m a big fan of using the XBee WiFi module to log data to a UDP port on my laptop. To view incoming data from the UDP port, I use a really useful tool called &lt;code>netcat&lt;/code>. Say the device is logging data to port 9750. I can listen in on the data by running,&lt;/p>
&lt;pre>&lt;code class="language-bash">netcat -ul 9751
&lt;/code>&lt;/pre>
&lt;p>and log the data if I like.&lt;/p>
&lt;pre>&lt;code class="language-bash">netcat -ul 9751 &amp;gt; log.txt
&lt;/code>&lt;/pre>
&lt;h2 id="3-plot-data-in-a-log-file-from-the-terminal">3. Plot data in a log file from the terminal&lt;/h2>
&lt;p>&lt;code>feedgnuplot&lt;/code> is a really useful Perl script that can read data from &lt;code>stdin&lt;/code> and pass it to &lt;code>gnuplot&lt;/code> for plotting. The only requirement is that the data arrive in a specific format: One sample per line, spaces between each data stream. This means your data in the file should look like this:&lt;/p>
&lt;pre>&lt;code>1.0 1.5 2.3
1.1 1.3 2.7
2.6 5.9 3.3
&lt;/code>&lt;/pre>
&lt;p>To plot the data:&lt;/p>
&lt;pre>&lt;code class="language-bash">cat log.txt | feedgnuplot --lines --autolegend
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>--autolegend&lt;/code> option automatically numbers each line in the graph. The &lt;code>--legend&lt;/code> option can be used to add custom legends. I highly recommend going through the
&lt;a href="http://manpages.ubuntu.com/manpages/zesty/man1/feedgnuplot.1.html" target="_blank" rel="noopener">feedgnuplot manpage&lt;/a> to find out about all the functionality that the script offers.&lt;/p>
&lt;h2 id="4-plot-only-specific-data">4. Plot only specific data&lt;/h2>
&lt;p>The &lt;code>awk&lt;/code> command is useful for filtering data that comes into the program line by line. A simple way it can be applied is to plot only specific columns in the text data.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat log.txt | awk '{ print $1, $2 }' | feedgnuplot --lines --autolegend
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>awk&lt;/code> command as shown here will filter out only columns 1 and 2 from the log file and pass it on to &lt;code>feedgnuplot&lt;/code>.&lt;/p>
&lt;p>&lt;code>awk&lt;/code> can also be used to do more complicated things like select lines with only numbers or only text. This can be useful if the log file contains other debug output lines as well and you want to filter out and plot just the lines that contain numeric data.
&lt;a href="https://en.wikipedia.org/wiki/AWK" target="_blank" rel="noopener">Wikipedia&lt;/a> has a pretty good introduction to &lt;code>awk&lt;/code>. I also found that a lot of the time, I could find what I needed for specific problems by searching stackoverflow.&lt;/p>
&lt;h2 id="5-process-data-before-plotting">5. Process data before plotting&lt;/h2>
&lt;p>What if I have some raw data in a log file that you want to run through some processing (more complicated than an &lt;code>awk&lt;/code> one liner)? I write a simple python script that reads lines from &lt;code>stdin&lt;/code> and writes the processed sample to &lt;code>stdout&lt;/code>. If I do this, I can plot the result by doing&lt;/p>
&lt;pre>&lt;code class="language-bash">cat log.txt | ./process_script.py | feedgnuplot --lines --autolegend
&lt;/code>&lt;/pre>
&lt;p>or log it to another file.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat log.txt | ./process_script.py &amp;gt; processed_data.txt
&lt;/code>&lt;/pre>
&lt;h2 id="6-interpret-packed-binary-data">6. Interpret packed binary data&lt;/h2>
&lt;p>If the data in the log file, or data that&amp;rsquo;s coming in from a serial port or network interface is in some packed binary format, there&amp;rsquo;s a handy tool called &lt;code>od&lt;/code> that can interpret it on the fly.
The command below will interpret data coming in as packets of 8 bytes as 2 byte integers.&lt;/p>
&lt;pre>&lt;code class="language-bash">netcat -ul 9751 | od -An -td2 -w8
&lt;/code>&lt;/pre>
&lt;p>&lt;code>od&lt;/code> is a versatile tool and as is usual for linux programs, I recommend reading the
&lt;a href="http://manpages.ubuntu.com/manpages/trusty/man1/od.1.html" target="_blank" rel="noopener">manpage&lt;/a> to know more about what it can do.&lt;/p>
&lt;h2 id="7-processplot-live-data-streams">7. Process/Plot live data streams&lt;/h2>
&lt;p>If I have data coming in from from a serial port or from a network interface and I want to create a real-time plot, &lt;code>feedgnuplot&lt;/code> has an option for that.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat /dev/ttyUSB0 | feedgnuplot --lines --autolegend --xlen 100 --stream 0.1
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>--xlen&lt;/code> option plots a window of the last 100 samples and the &lt;code>--stream&lt;/code> option updates the plot as new data comes in. The parameter 0.1 is the refresh rate.&lt;/p>
&lt;p>I can even run the live data stream through my processing algorithm before plotting.&lt;/p>
&lt;pre>&lt;code class="language-bash">netcat -ul 9750 | ./process_data.py | feedgnuplot --lines --autolegend --xlen 100 --stream 0.1
&lt;/code>&lt;/pre>
&lt;h2 id="8-redirecting-to-multiple-programs">8. Redirecting to multiple programs.&lt;/h2>
&lt;p>Sometimes I&amp;rsquo;ve been in a situation where I want to monitor data coming in from a serial port &lt;em>and&lt;/em> log it to a file at the same time. One way of doing this is to write a python script that reads data from &lt;code>stdin&lt;/code>, logs it to a file and also writes the same data to &lt;code>stdout&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat /dev/ttyUSB0 | ./log_and_print.py | feedgnuplot --lines --xlen 100 --stream 0.1
&lt;/code>&lt;/pre>
&lt;p>This is good if you only want to do one extra thing with the output. There is a better solution however that uses the &lt;code>tee&lt;/code> command.&lt;/p>
&lt;pre>&lt;code class="language-bash">cat /dev/ttyUSB0 | tee &amp;gt;(command1) &amp;gt;(command2) &amp;gt;(logfile.txt) | feedgnuplot --lines --autolegend --xlen 100 --stream 0.1
&lt;/code>&lt;/pre>
&lt;p>This technique is quite versatile and can be used in many ways. For example, I can use tee to get the raw data from the serial port, plot it, pass it through a data processing script and plot the output of that result as well for a comparison.&lt;/p>
&lt;h2 id="summing-up">Summing up&lt;/h2>
&lt;p>I&amp;rsquo;m sure that there are many more clever ways to combine and compose these commands to make prototyping easier as well as commands that I don&amp;rsquo;t know about yet. If there is one thing that I&amp;rsquo;ve learned after using linux for a few years it&amp;rsquo;s that it often has modest looking command line tools that can do much more than a lot of GUI based applications if you spend just a little time to go through the manpage. I hope that this post inspires others to take a second look at the free tools that come with most linux distros. Some of them could really simplify your workflow!&lt;/p></description></item><item><title>Programming Complex Dataflows in C</title><link>https://www.ashwinnarayan.com/post/dataflow-programming-in-c/</link><pubDate>Tue, 01 Aug 2017 00:15:14 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/dataflow-programming-in-c/</guid><description>&lt;p>Over the past few months I&amp;rsquo;ve been spending a lot of time on implementing various signal processing algorithms in C/C++. Things like Kalman Filters, various types of FIR filters and finite state machines. The number of steps needed to implement each these algorithms were fairly small and in the beginning I tried to put all the functionality of these implementations into simple to use C++ classes. This made things look neater and also fit in quite well with the Arduino programming framework (I was implementing a lot of these algorithms on Arduino compatible microcontrollers like the Teensy). However, once I started combining different algorithms together to make something bigger, the code started becoming very messy. Making changes and debugging was starting to take longer and longer. In many instances, I had to go back and change the deisgn and interface of my C++ classes when I realized that the way I initially implemented it made it impossible or very difficult to do some step in the algorithm. I decided to take some time to figure out how I can do better. I wanted to find out a systematic method - a &amp;ldquo;meta-programming&amp;rdquo; algorithm if you will - that would tell me the way I should implement the algorithm so that the code is easy to write and more importantly, easy to read and debug.&lt;/p>
&lt;h2 id="representing-the-algorithm">Representing the Algorithm&lt;/h2>
&lt;p>Before I could start solving the problem I needed to decide how to represent a general data processing algorithm. What is a representation that can capture most if not all of the types of algorithms that I wanted to implement? I remembered that in a lot of papers that I&amp;rsquo;ve read, the authors used Simulink to implement their algorithm. So I decided to start out by assuming that I can represent what I want to do in the form of a block diagram - much like the block diagrams that you can draw in Simulink. It turns out that as long as they don&amp;rsquo;t have any cycles or loops, block diagrams with arrows representing the flow of data between the blocks can be represented by a mathematical structure called a Directed Acyclic Graph.&lt;/p>
&lt;h2 id="directed-acyclic-graphs">Directed Acyclic Graphs&lt;/h2>
&lt;p>
&lt;a href="https://en.wikipedia.org/wiki/Graph_theory" target="_blank" rel="noopener">Graphs&lt;/a> as a mathematical structure (different from the graphs that you use to plot data) are useful for representing relationships between things. Intuitively I think of them as circles connected by lines. The circles represent things and the lines represent some type of relationship between the things. If this seems very abstract, that&amp;rsquo;s because graphs can be applied to a &lt;em>lot&lt;/em> of different things and when an concept is that general, it tends to be very abstract. As an example, a graph can be used to represent an electrical circuit. Each discrete component like a resistor or an LED can be considered a node or vertex in the graph (circles). The wires that connect these components together can be considered the edges of the graph.&lt;/p>
&lt;figure id="figure-a-graph-representing-the-collatz-sequence-and-some-unrelated-drawings">
&lt;a data-fancybox="" href="https://imgs.xkcd.com/comics/collatz_conjecture.png" data-caption="A graph representing the collatz sequence and some unrelated drawings.">
&lt;img src="https://imgs.xkcd.com/comics/collatz_conjecture.png" alt="" >
&lt;/a>
&lt;figcaption>
A graph representing the collatz sequence and some unrelated drawings.
&lt;/figcaption>
&lt;/figure>
&lt;p>A
&lt;a href="https://en.wikipedia.org/wiki/Directed_graph" target="_blank" rel="noopener">directed graph&lt;/a> is a graph in which the edges connecting the nodes have a direction. The graph in the image from xkcd is a directed graph since it has arrows connecting the nodes of the graph.&lt;/p>
&lt;p>A
&lt;a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="noopener">directed acyclic graph&lt;/a> (DAG) is a directed graph that does not have &lt;em>cycles&lt;/em> in it. This means that there is no way to start at a node in the graph and follow the arrows from node to node and reach the node you started at. A directed acyclic graph is useful for modeling dependencies. If you&amp;rsquo;re planning to understand some big concept in science - General Relativitiy for example - there are prerequisite ideas that you need to understand first. A subject and it&amp;rsquo;s prerequisites can be arranged in the form of a directed acyclic graph.&lt;/p>
&lt;figure id="figure-a-directed-acyclic-graph-showing-the-dependencies-for-learning-about-markov-chains">
&lt;a data-fancybox="" href="https://www.ashwinnarayan.com/img/markov_chains.png" data-caption="A directed acyclic graph showing the dependencies for learning about Markov Chains.">
&lt;img src="https://www.ashwinnarayan.com/img/markov_chains.png" alt="" >
&lt;/a>
&lt;figcaption>
A directed acyclic graph showing the dependencies for learning about Markov Chains.
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="topological-sorting">Topological Sorting&lt;/h2>
&lt;p>Given a DAG showing the dependencies for learning about Markov chains like in the image above, one might ask the question: Is there a way to list the nodes of the graph in correct learning order &lt;em>i.e&lt;/em> the order in which any dependencies for a node appear before the node itself is listed. It turns out that
&lt;a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="noopener">you can&lt;/a>! Every DAG has at least one way in which we can make this sorted list and there are a few algorithms for doing so.&lt;/p>
&lt;p>So if you want to learn something new, topologically sorting a dependency graph of the topic is a nice approach! In fact, this is exactly what the website
&lt;a href="https://metacademy.org" target="_blank" rel="noopener">Metacademy&lt;/a> does! It gives you the order in which to learn things using topological sorting.&lt;/p>
&lt;h2 id="dataflows">Dataflows&lt;/h2>
&lt;p>So how does this relate to programming algorithms represented by block diagrams in C? I thought of the block diagram as a directed acyclic graph. The blocks which represent steps in the data processing algorithm are represented by nodes in the graph and the arrows that connect the blocks represent the flow of data. In programming, the nodes in the block diagram can be naturally represented by functions whose arguments are the incoming edges and the return values are the outgoing edges. This also means that the edges themselves can be naturally represented by variables in the C program. Once I&amp;rsquo;ve defined all the edge variables and block functions, I need to figure out what is the correct order in which to call each of these block functions. The &amp;ldquo;correct&amp;rdquo; order can be defined as the order in which each function is only called once all the variables that represent the input edges to the block have been updated (if necessary) in the current iteration of the main loop of the program. It turns out that this correct order is the same as the topologically sorted order of the function blocks.&lt;/p>
&lt;p>So to summarize the systematic meta algorithm to implement a data processing algorithm in C:&lt;/p>
&lt;p>Start out with a fresh &lt;code>.h&lt;/code> file which will contain your implementation&lt;/p>
&lt;ol>
&lt;li>Construct a block diagram of the algorithm showing the data flow.&lt;/li>
&lt;li>Make sure that the block diagram is a directed acyclic graph.&lt;/li>
&lt;li>Give names to each node and edge.&lt;/li>
&lt;li>For each edge in the graph, declare a C variable in the global scope. I use the &lt;code>static&lt;/code> keyword if I want to make sure that the variable is only visible inside the header file. The data type of the C variable depends on the node that the edge originates from.&lt;/li>
&lt;li>For each node in the graph, declare a function that takes as arguments pointers to both the input and and output edge variables from the node. It is useful to declare the input pointers as &lt;code>const&lt;/code> to ensure that the function does not modify the data in the edge variables. The function uses the input to carry out the processing step and modifies the output edge variables. I use &lt;code>static&lt;/code> variables inside the function if I need to keep track of any state (like for finite state machines).&lt;/li>
&lt;li>Any parameters needed by the processing step inside the function can either be declared globally or as a const argument of the function. Personally, I like to have the simple parameters as &lt;code>#define&lt;/code>s at the top of the header file so I can tweak/change them easily.&lt;/li>
&lt;li>If there are parameters that need to be modified/tuned during execution, they can be declared as variables global to the file. This is useful if you&amp;rsquo;re running a code that implements something like a PID controller and you want to tune the gains of the controller online. I use an
&lt;a href="https://github.com/RationalAsh/CmdArduino" target="_blank" rel="noopener">Arduino library&lt;/a> that listens to incoming commands on one of the Serial ports.&lt;/li>
&lt;li>Define an initialization function that initializes all the edge variables to an initial state (if necessary).&lt;/li>
&lt;li>Define a main function graph execution function that calls the block functions in the topologically sorted order.&lt;/li>
&lt;/ol>
&lt;p>Here&amp;rsquo;s a rough outline of what the &lt;code>.h&lt;/code> file will look like.&lt;/p>
&lt;pre>&lt;code class="language-C">#ifndef DATA_PROC_H
#define DATA_PROC_H
//#defines and parameters
#define PARAM1 0
//Define the edge variables with the appropriate type
float e1, e2, e3, e4
int e5;
//Define the node function prototypes
void F1(const float in1, const float in2, float *out);
void F2(const float in1, const float in2, float *out);
void F3(const float in1, int *out);
//Define the initialization function
void data_proc_init()
{
e1 = 0;
e2 = 0;
e3 = 0;
e4 = 0;
}
//Define the main execution pipeline function
void data_proc_exec()
{
//Node functions called in the topologically sorted order
F1(e1, e2, &amp;amp;e3);
F2(e2, e3, &amp;amp;e4);
F3(e4, &amp;amp;e5);
}
//Function implementations
//Implement the node functions here
#endif
&lt;/code>&lt;/pre>
&lt;p>And in the main C file:&lt;/p>
&lt;pre>&lt;code class="language-C">#include &amp;quot;data_proc.h&amp;quot;
int main(int argc, char** argv)
{
//Run the initialization function
data_proc_init();
while(loop_condition)
{
//Execute pipeline function in loop
data_proc_exec();
}
}
&lt;/code>&lt;/pre>
&lt;p>I&amp;rsquo;ve noticed that if I stick to these rules consistently, my code is generally much easier to read. As long as I give descriptive names to the block functions, I only need to look at the main execution function to figure out the flow of the program. Debugging becomes easier too! It becomes a matter of adding one function from the topologically sorted list at a time and checking the output for correctess.&lt;/p>
&lt;p>While the meta algorithm that I wrote down is specifically for C, this method can easily be extended to other programming languages. Python would make doing this even easier as it is much more flexible with functions returning data. Instead of taking in pointers to the output variables as arguments, the function can actually return tuples of data that can be assigned to the output edge variables.&lt;/p>
&lt;p>I&amp;rsquo;m sure that this method will have some limitations. One I can see right away is that it uses a lot of variables. One for each edge and even more for the static variables inside the function. On memory constrained systems like small microcontrollers, the RAM can run out pretty fast (Declaring non-tweakable parameters as being stored in the code ROM should help with this a bit). Another problem is the question of what to do with algorithms that can&amp;rsquo;t be represented as a DAG. I don&amp;rsquo;t know if it&amp;rsquo;s possible to represent all possible algorithms using DAGs (A quick google search did not turn up any conclusive answers). I am also unsure how this model can be used for programming things like GUIs which sit around and wait for events to happen most of the time. However, when implementing control and signal processing algorithms, I find this method is singularly better than the others I&amp;rsquo;ve tried.&lt;/p></description></item><item><title>Real-Time Programming with Xenomai 3 - Part 2: Writing a simple periodic task.</title><link>https://www.ashwinnarayan.com/post/xenomai-realtime-programming-part-2/</link><pubDate>Sat, 20 May 2017 23:10:16 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/xenomai-realtime-programming-part-2/</guid><description>&lt;p>Xenomai gets tasks to run in real-time by having a co-kernel running alongside the regular linux kernel handling all the time critical tasks. The Xenomai co-kernel is able to do this because of the i-pipe patch that the custom kernel is compiled with. This patch adds an &lt;em>interrupt pipeline&lt;/em> that sits between the hardware of the computer and any kernels running on the hardware. The interrupt pipeline has domains which can be assigned a priority. When any interrupt, system call or processor fault comes in, the domain with the higher priority is allowed to process them first. The Xenomai co-kernel has the higher priority in an ipipe patched kernel. The Xenomai website has a
&lt;a href="https://xenomai.org/documentation/branches/v2.3.x/Life-with-Adeos-rev_B.pdf" target="_blank" rel="noopener">more detailed explanation of how it works&lt;/a>.&lt;/p>
&lt;p>Before I start with the explanation, here&amp;rsquo;s the full code and Makefile for those who just want to compile some code and get started. The documentation for all the functions used in the code and more can be found
&lt;a href="https://xenomai.org/documentation/xenomai-3/pdf/xeno3prm.pdf" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;p>The code:&lt;/p>
&lt;pre>&lt;code class="language-C">#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;alchemy/task.h&amp;gt;
#include &amp;lt;alchemy/timer.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#define CLOCK_RES 1e-9 //Clock resolution is 1 ns by default
#define LOOP_PERIOD 1e7 //Expressed in ticks
//RTIME period = 1000000000;
RT_TASK loop_task;
void loop_task_proc(void *arg)
{
RT_TASK *curtask;
RT_TASK_INFO curtaskinfo;
int iret = 0;
RTIME tstart, now;
curtask = rt_task_self();
rt_task_inquire(curtask, &amp;amp;curtaskinfo);
int ctr = 0;
//Print the info
printf(&amp;quot;Starting task %s with period of 10 ms ....\n&amp;quot;, curtaskinfo.name);
//Make the task periodic with a specified loop period
rt_task_set_periodic(NULL, TM_NOW, LOOP_PERIOD);
tstart = rt_timer_read();
//Start the task loop
while(1){
printf(&amp;quot;Loop count: %d, Loop time: %.5f ms\n&amp;quot;, ctr, (rt_timer_read() - tstart)/1000000.0);
ctr++;
rt_task_wait_period(NULL);
}
}
int main(int argc, char **argv)
{
char str[20];
//Lock the memory to avoid memory swapping for this program
mlockall(MCL_CURRENT | MCL_FUTURE);
printf(&amp;quot;Starting cyclic task...\n&amp;quot;);
//Create the real time task
sprintf(str, &amp;quot;cyclic_task&amp;quot;);
rt_task_create(&amp;amp;loop_task, str, 0, 50, 0);
//Since task starts in suspended mode, start task
rt_task_start(&amp;amp;loop_task, &amp;amp;loop_task_proc, 0);
//Wait for Ctrl-C
pause();
return 0;
}
&lt;/code>&lt;/pre>
&lt;p>The Makefile&lt;/p>
&lt;pre>&lt;code class="language-Makefile">SKIN=alchemy
MAIN_SRC=cyclic_test
TARGET=cyclic_test
LM=-lm
CFLAGS := $(shell xeno-config --skin=alchemy --cflags)
LDFLAGS := $(LM) $(shell xeno-config --skin=alchemy --ldflags)
CC := $(shell xeno-config --cc)
$(TARGET): $(MAIN_SRC).c
$(CC) -o $@ $&amp;lt; $(CFLAGS) $(LDFLAGS)
&lt;/code>&lt;/pre>
&lt;p>First, the headers, defines and global variables:&lt;/p>
&lt;pre>&lt;code class="language-C">#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;alchemy/task.h&amp;gt;
#include &amp;lt;alchemy/timer.h&amp;gt;
#include &amp;lt;math.h&amp;gt;
#define CLOCK_RES 1e-9 //Clock resolution is 1 ns by default
#define LOOP_PERIOD 1e7 //Expressed in ticks
//RTIME period = 1000000000;
RT_TASK loop_task;
&lt;/code>&lt;/pre>
&lt;p>The includes are fairly standard. The Xenomai libraries are included by the &lt;code>alchemy/task.h&lt;/code> and the &lt;code>alchemy/timer.h&lt;/code> statements. I&amp;rsquo;ve deifined CLOCK_RES (The resolution of the clock) and LOOP_PERIOD (The period with which I want the periodic task to run) for convenience. The variable &lt;code>RT_TASK loop_task&lt;/code> will hold an address to a task descriptor for a Real-Time task/thread that Xenomai will create.&lt;/p>
&lt;p>Jumping ahead to &lt;code>main()&lt;/code>, the first line that you come across that might be unfamiliar is:&lt;/p>
&lt;pre>&lt;code class="language-C"> //Lock the memory to avoid memory swapping for this program
mlockall(MCL_CURRENT | MCL_FUTURE);
&lt;/code>&lt;/pre>
&lt;p>The mlockall() function is actually a function provided by linux rather than Xenomai and is provided by the &lt;code>&amp;lt;sys/mman.h&amp;gt;&lt;/code> include. In Part one, I talked about how a real-time task can miss its deadlines if the task is swapped out of memory by the operating system. This line of code makes sure that the memory that is currently mapped to the address space of the process as well as any memory that gets mapped into the address space of the process in the future is &amp;ldquo;locked&amp;rdquo; into RAM and cannot get swapped out.&lt;/p>
&lt;p>In the next few lines of code, a new real-time task is created.&lt;/p>
&lt;pre>&lt;code class="language-C"> //Create the real time task
sprintf(str, &amp;quot;cyclic_task&amp;quot;);
rt_task_create(&amp;amp;loop_task, str, 0, 50, 0);
&lt;/code>&lt;/pre>
&lt;p>The rt_task_create() function creates a new real-time task using Xenomai&amp;rsquo;s Alchemy API. The first argument is the RT_TASK variable that holds the address of the task descriptor. The second is a string that holds a name for the task. You can give it a descriptive name. The third argument is the size of the stack for the new task. Passing a zero makes the function use a system dependent default. The next argument is the &lt;em>priority&lt;/em> of the task. This tells the real-time scheduler how important the task is. Higher priority tasks can interrupt lower priority tasks. The last argument is the task creation mode into which you can pass bitwise OR&amp;rsquo;ed flags. For example, passing the T_JOINABLE flag allows you to call the rt_task_join() function to wait on the task to finish. In this code sample, I&amp;rsquo;m just passing in zero, which is the default mode. The function returns a 0 if the task is successfully created. Ideally, you should check for this and print an error if the return value is not zero. However, for this simple example, I&amp;rsquo;m omitting this.&lt;/p>
&lt;p>A real-time task created using rt_task_create() starts off dormant. To begin the execution of the task, you need to call the rt_task_start() function.&lt;/p>
&lt;pre>&lt;code class="language-C"> //Since task starts in suspended mode, start task
rt_task_start(&amp;amp;loop_task, &amp;amp;loop_task_proc, 0);
&lt;/code>&lt;/pre>
&lt;p>The first two arguments are the task descriptor and a pointer to the function that implements the real-time task. The last argument is a pointer to a user defined struct that will be passed on as arguments to the real-time task function.&lt;/p>
&lt;p>Finally we call the pause() function and wait for a Ctrl-C signal from the terminal.&lt;/p>
&lt;p>Once rt_task_start() is called, the real-time task starts executing. To make a Xenomai task periodic, you need to call the rt_task_set_periodic() function.&lt;/p>
&lt;pre>&lt;code class="language-C"> //Make the task periodic with a specified loop period
rt_task_set_periodic(NULL, TM_NOW, LOOP_PERIOD);
&lt;/code>&lt;/pre>
&lt;p>If you&amp;rsquo;re calling this function from outside a real-time task, you need to pass in an RT_TASK as the first argument. However, you can also call this function from inside a real-time task with a &lt;code>NULL&lt;/code> first argument. &lt;code>TM_NOW&lt;/code> tells Xenomai to start timing the task right away and LOOP period is the period of the task in ticks of the clock. Since the default resolution of the clock is 1 nanosecond, this argument is the same as the period you want for the task expressed in nanoseconds.&lt;/p>
&lt;p>Now we can start the infinite loop of the task.&lt;/p>
&lt;pre>&lt;code class="language-C">//Start the task loop
while(1){
printf(&amp;quot;Loop count: %d, Loop time: %.5f ms\n&amp;quot;, ctr, (rt_timer_read() - tstart)/1000000.0);
ctr++;
rt_task_wait_period(NULL);
}
&lt;/code>&lt;/pre>
&lt;p>In the loop I increment a simple counter and also use the rt_timer_read() function to get the current system time so I can print to the terminal and check if the task is running in real-time. The rt_task_wait_period() blocks the loop till the start of the next period.&lt;/p>
&lt;p>When I started out trying to compile and run Xenomai with no prior experience, it seemed like quite a daunting task. The Xenomai documentation although excellent is written for programmers and as a result, it can be difficult to write your very first program. However, once you do write your very first program and you get a good idea for how it works, things go very smoothly. This post, like the one before is a bit long but hopefully, someone trying to get started with Xenomai for the first time will find it useful!&lt;/p></description></item><item><title>Real-Time Programming with Xenomai 3 - Part 1: Installation and Basic Setup</title><link>https://www.ashwinnarayan.com/post/xenomai-realtime-programming/</link><pubDate>Wed, 17 May 2017 00:07:36 +0800</pubDate><guid>https://www.ashwinnarayan.com/post/xenomai-realtime-programming/</guid><description>&lt;p>In my lab, we recently started moving away from Simulink&amp;rsquo;s Real-Time packages and towards Real-Time Linux for implementing the low level control of our robots. I thought I would document what I went through to get
&lt;a href="https://xenomai.org/" target="_blank" rel="noopener">Xenomai&lt;/a> (A Real-Time framework for linux) working stably as a resource for others trying to get started on the same thing.&lt;/p>
&lt;h2 id="what-is-real-time">What is Real-Time?&lt;/h2>
&lt;p>The word &amp;ldquo;real-time&amp;rdquo; is used in a lot of different fields to mean different things. Some people also mistake real-time systems for high performance systems. I use the word real-time to refer to systems that guarantee consistent responses to events within time constraints (also called &lt;em>deadlines&lt;/em>) with low variability regardless of system load. This is something that&amp;rsquo;s not easy to do. A normal linux operating system is not real-time.&lt;/p>
&lt;p>Say you want to implement a program in C on a regular linux computer that toggles a pin on the parallel port every millisecond. A naive implementation would be as a simple loop that toggles the pin and waits for 1 millisecond. This may work OK most of the time but the moment the system is loaded by something else, the program may start running its loops slower because the process may be preempted by the kernel or be swapped out of memory in favor of another memory intensive program.&lt;/p>
&lt;p>A real-time operating system will be designed so that regardless of the system load, the program that toggles the pin can do the operation every millisecond give or take a few microseconds. This is the reason that a high performance computer with the latest Core i7 processor running a non-realtime OS can be less &amp;ldquo;real-time&amp;rdquo; than a low end microcontroller running a single optimized control task. Real-time systems are used in mission critical control systems such as those on fly-by-wire aircraft, satellites, exoplanetary rovers, cardiac pacemakers or car engine control units.&lt;/p>
&lt;p>A real-time operating system (RTOS) usually has an API for creating and running real-time tasks and uses a scheduling algorithm that&amp;rsquo;s different from what&amp;rsquo;s used by general purpose operating systems like Windows and Linux. There are many RTOSs in the wild.
&lt;a href="https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems" target="_blank" rel="noopener">Wikipedia has a great list of them.&lt;/a> Some RTOS&amp;rsquo;s like FreeRTOS are meant to be used in embedded microcontrollers. Some - like RTLinux are used when the real-time application needs to be run on a full blown operating system. Using real-time with full operating systems also allow you to take advantage of a lot of existing software and functionality that the operating system will have like networking and math libraries like GSL.&lt;/p>
&lt;h2 id="real-time-operating-systems-for-control">Real-Time Operating Systems for Control&lt;/h2>
&lt;p>When implementing a control system such as a PID controller digitally, real-time response times become very important. One of the assumptions made when developing digital control systems is that of constant sampling time. When you implement a control loop in code, if the constant sampling rate assumption is not met or if the controller responds too late to changes in the system state, it could lead to the system becoming unstable.&lt;/p>
&lt;p>The choice of using Xenomai to implement our real time controllers was mostly due to the fact that it has very good documentation apart from being free and open source.&lt;/p>
&lt;h2 id="installing-xenomai">Installing Xenomai&lt;/h2>
&lt;p>To get Xenomai running on a linux system, you need to compile a modified kernel. I used Lubuntu 12.04 (which ships with kernel 3.2). The version of the kernel that I compiled is 3.18.20. Choose a version of the kernel that is close in version number to the one that the distribution ships with to minimize issues.&lt;/p>
&lt;p>Before starting, create a fresh folder to act as your workspace. Also make sure you have plenty of disk space available. The 3.18.20 kernel requires just over 11 GB of free disk space to compile successfully. Newer versions of the kernel need more. 20 GB should be safe.&lt;/p>
&lt;p>These are the steps that I&amp;rsquo;ve been following to get a freshly installed Lubuntu system working with xenomai. Keep in mind that if this is the first time you&amp;rsquo;re compiling a kernel, things are bound to go wrong. Be willing to debug your compilation patiently. I had to go through the compilation process dozens of times, making tweaks at each step to get my first successful kernel image.&lt;/p>
&lt;ol>
&lt;li>Go to the downloads section of the xenomai website and look for an ipipe patch (it&amp;rsquo;s a file with a .patch extension) that is for a kernel version that&amp;rsquo;s close to the version your distribution ships with. This is the kernel version that you&amp;rsquo;ll be compiling.&lt;/li>
&lt;li>Go to kernel.org and download the version of the linux kernel that exactly matches the kernel version on the ipipe patch file name.&lt;/li>
&lt;li>Download the xenomai source from the xenomai website.&lt;/li>
&lt;li>Unzip the files into separate folders.&lt;/li>
&lt;li>Apply the xenomai patch to the kernel:
&lt;code>xenomai-3.0.4/scripts/prepare-kernel.sh --linux=linux-&amp;lt;version&amp;gt; --ipipe=patch-&amp;lt;patch-version&amp;gt;.patch --arch=x86_64&lt;/code>&lt;/li>
&lt;li>&lt;code>cd&lt;/code> into the kernel source directory and run &lt;code>make menuconfig&lt;/code> and make the following changes:
&lt;ul>
&lt;li>Power Management and ACPI Options -&amp;gt; CPU Frequency Scaling - DISABLE&lt;/li>
&lt;li>Power Management and ACPI Options -&amp;gt; ACPI Support -&amp;gt; Processor - DISABLE&lt;/li>
&lt;li>Power Management and ACPI Options -&amp;gt; CPU Idle -&amp;gt; CPU Idle PM Support - DISABLE&lt;/li>
&lt;li>Device Drivers -&amp;gt; Input Device Support -&amp;gt; Generic Input Layer -&amp;gt; Miscellaneous Devices -&amp;gt; PC Speaker Support - DISABLE&lt;/li>
&lt;li>Processor type and features -&amp;gt; Processor family: Select the exact processor on the motherboard. This is important for things to work properly.&lt;/li>
&lt;li>Xenomai/cobalt -&amp;gt; Core Features -&amp;gt; Shared Interrupts - ENABLE (If you want shared interrupts to work)&lt;/li>
&lt;li>In the Xenomai/Cobalt drivers section enable all the drivers for the devices that you’ll be using. Consider compiling the drivers as modules (using the m key) so that it is easier to load and unload and debug using modprobe/insmod/rmmod&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Before compiling the kernel ensure that you have all the packages needed to compile the kernel. Use apt-get or any package manager.
&lt;ul>
&lt;li>gcc&lt;/li>
&lt;li>make&lt;/li>
&lt;li>Autoconf&lt;/li>
&lt;li>libtool&lt;/li>
&lt;li>kernel-package&lt;/li>
&lt;li>build-essential&lt;/li>
&lt;li>fakeroot&lt;/li>
&lt;li>dh-autoconf&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>cd&lt;/code> into the kernel source folder again and compile the kernel using the command: &lt;code>sudo CONCURRENCY_LEVEL=8 CLEAN_SOURCE=no fakeroot make-kpkg --initrd --append-to-version -xenomai-realtime --revision 1.0 kernel_image kernel_headers&lt;/code>&lt;/li>
&lt;li>Once the compile is complete, in the directory above the kernel source, there should be two .deb files: One starting with linux-headers and one starting with linux-image. These are the kernel image and header debian packages that you can use to install the kernel.&lt;/li>
&lt;li>Use &lt;code>sudo dpkg -i &amp;lt;package-name&amp;gt;&lt;/code> to install each of the packages&lt;/li>
&lt;li>Update the initramfs using the command &lt;code>sudo update-initramfs -c -k &amp;lt;kernel-version&amp;gt;-xenomai-realtime &amp;amp;&amp;amp; sudo update-grub&lt;/code>&lt;/li>
&lt;li>&lt;code>cd&lt;/code> into the unzipped xenomai source folder and run &lt;code>sudo ./configure&lt;/code> followed by &lt;code>sudo make &amp;amp;&amp;amp; make install&lt;/code>&lt;/li>
&lt;li>Reboot and select the new kernel in the grub menu (Hold down shift at boot time to bring up the menu).&lt;/li>
&lt;/ol>
&lt;p>If everything went well, xenomai should be installed on your system now. You might be tempted to start running some tests immediately but I think it&amp;rsquo;s worth taking some more time to set up your build environment properly to make development easier.&lt;/p>
&lt;p>Some important xenomai related executables (including xeno-config) are in the &lt;code>/usr/xenomai/bin&lt;/code> folder. You need to append this to the &lt;code>PATH&lt;/code> environment variable. The library files that the code is linked against are installed in the &lt;code>/usr/xenomai/lib&lt;/code> folder. You need to append this to the &lt;code>LD_LIBRARY_PATH&lt;/code> environment variable. My preferred way of doing this is to edit the ~/.bashrc file with export statements. Open up your .bashrc file (it&amp;rsquo;s in your home folder, hidden) by running &lt;code>leafpad ~/.bashrc&lt;/code> and add the following two lines to it at the end.&lt;/p>
&lt;pre>&lt;code class="language-export">export LD_LIBRARY_PATH=”/usr/xenomai/lib:$LD_LIBRARY_PATH”```
When you try to run a compiled xenomai application afterwards, you will need to run it as superuser (using the sudo command). It might complain that it cannot find the library files. This is because environment variables are cleared when running a program as root. To fix this permanently:
1. Open up a terminal and go to the `/etc/ld.so.conf.d` folder.
2. Create a new file called xenomai.conf (as superuser)
3. Add the line `/usr/xenomai/lib` to the file.
4. Run `sudo ldconfig`
_Now_ you can finally try to run some tests. If everything went well, running `sudo /usr/xenomai/bin/latency` should run the latency test program that outputs some numbers on to the terminal that shows you the latency figures of your system. It should be in the tens of microseconds range (If not something's wrong).
The process of getting real-time linux with Xenomai or any other framework running for the first time can be a little painful but once your installation is stable, it'll serve you well for a very long time. Once you have a working compiled kernel package, installation on future hardware will also go much faster.
In Part 2 of this series of blog posts, I will go through the process of writing a simple periodic real-time task using Xenomai's real-time API. &lt;/code>&lt;/pre></description></item></channel></rss>