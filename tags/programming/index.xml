<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Ashwin Narayan</title>
    <link>http://www.ashwinnarayan.com/tags/programming/</link>
    <description>Recent content in Programming on Ashwin Narayan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Ashwin Narayan</copyright>
    <lastBuildDate>Sun, 13 Aug 2017 19:30:14 +0800</lastBuildDate>
    <atom:link href="/tags/programming/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bash Recipes for Doing Science!</title>
      <link>http://www.ashwinnarayan.com/post/bash-recipes-for-science/</link>
      <pubDate>Sun, 13 Aug 2017 19:30:14 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/bash-recipes-for-science/</guid>
      <description>

&lt;p&gt;When prototyping programs that deal with lots of data on an Arduino and other embedded systems or even on full blown computers, it&amp;rsquo;s really useful to have a quick tool for plotting the output of the program. Initially, I used python for doing this. Python is a beautifully simple language and between Numpy, Scipy and Matplotlib, you can do pretty much anything you want with data; from doing simple plotting to running machine learning algorithms on the data. However, when all you want is to quickly plot a text file containing some data, breaking out a text editor to write a python script can get annoying especially if you do it many times a day.&lt;/p&gt;

&lt;p&gt;That was when I came across this interesting video from the computerphile YouTube channel.&lt;/p&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/vT_J6xc-Az0&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;It&amp;rsquo;s a fantastic interview with Brian Kernighan where he talks about his work on Unix and in particular then &lt;code&gt;awk&lt;/code&gt; command line tool. I&amp;rsquo;ve been using linux as my primary operating system for quite some time now and I do a lot of programming in it. So I am fairly comfortable with using the terminal for compiling and debugging code. But there was never a situation where I had to sit down and learn about all the terminal based utilities that were available. As I was watching Brian Kernighan describe &lt;code&gt;awk&lt;/code&gt; and how it works, I started to realize that I could really use this tool to my advantage when playing around with data. That was when I decided take a closer look at all the tools that were available on the linux terminal to see what I was missing out on.&lt;/p&gt;

&lt;p&gt;Over time I&amp;rsquo;ve developed a few &amp;ldquo;recipes&amp;rdquo; that are really useful to me and I thought I&amp;rsquo;d share some that I&amp;rsquo;ve found particularly useful.&lt;/p&gt;

&lt;h2 id=&#34;1-log-and-monitor-a-serial-port&#34;&gt;1. Log and monitor a serial port&lt;/h2&gt;

&lt;p&gt;Logging and monitoring serial ports is a really common thing to have to do - especially if you&amp;rsquo;re working with embedded systems like the Arduino. It&amp;rsquo;s a standard way of getting data off the microcontroller. Checking what&amp;rsquo;s being logged to the serial port is as simple as running:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /dev/ttyUSB0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes the command exits immediately or shows garbled output (due to the wrong baud rate). You can use &lt;code&gt;stty&lt;/code&gt; to change the serial port settings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;stty -F /dev/ttyUSB0 115200 min 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can also log the data from the serial port conveniently to a text file,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /dev/ttyUSB0 &amp;gt; logfilename.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-log-and-monitor-network-ports&#34;&gt;2. Log and monitor network ports&lt;/h2&gt;

&lt;p&gt;One of the ways to get data off an Arduino is using an XBee device to wirelessly transmit it. I&amp;rsquo;m a big fan of using the XBee WiFi module to log data to a UDP port on my laptop. To view incoming data from the UDP port, I use a really useful tool called &lt;code&gt;netcat&lt;/code&gt;. Say the device is logging data to port 9750. I can listen in on the data by running,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netcat -ul 9751
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and log the data if I like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netcat -ul 9751 &amp;gt; log.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-plot-data-in-a-log-file-from-the-terminal&#34;&gt;3. Plot data in a log file from the terminal&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;feedgnuplot&lt;/code&gt; is a really useful Perl script that can read data from &lt;code&gt;stdin&lt;/code&gt; and pass it to &lt;code&gt;gnuplot&lt;/code&gt; for plotting. The only requirement is that the data arrive in a specific format: One sample per line, spaces between each data stream. This means your data in the file should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.0 1.5 2.3
1.1 1.3 2.7
2.6 5.9 3.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To plot the data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat log.txt | feedgnuplot --lines --autolegend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;--autolegend&lt;/code&gt; option automatically numbers each line in the graph. The &lt;code&gt;--legend&lt;/code&gt; option can be used to add custom legends. I highly recommend going through the &lt;a href=&#34;http://manpages.ubuntu.com/manpages/zesty/man1/feedgnuplot.1.html&#34; target=&#34;_blank&#34;&gt;feedgnuplot manpage&lt;/a&gt; to find out about all the functionality that the script offers.&lt;/p&gt;

&lt;h2 id=&#34;4-plot-only-specific-data&#34;&gt;4. Plot only specific data&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;awk&lt;/code&gt; command is useful for filtering data that comes into the program line by line. A simple way it can be applied is to plot only specific columns in the text data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat log.txt | awk &#39;{ print $1, $2 }&#39; | feedgnuplot --lines --autolegend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;awk&lt;/code&gt; command as shown here will filter out only columns 1 and 2 from the log file and pass it on to &lt;code&gt;feedgnuplot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;awk&lt;/code&gt; can also be used to do more complicated things like select lines with only numbers or only text. This can be useful if the log file contains other debug output lines as well and you want to filter out and plot just the lines that contain numeric data. &lt;a href=&#34;https://en.wikipedia.org/wiki/AWK&#34; target=&#34;_blank&#34;&gt;Wikipedia&lt;/a&gt; has a pretty good introduction to &lt;code&gt;awk&lt;/code&gt;. I also found that a lot of the time, I could find what I needed for specific problems by searching stackoverflow.&lt;/p&gt;

&lt;h2 id=&#34;5-process-data-before-plotting&#34;&gt;5. Process data before plotting&lt;/h2&gt;

&lt;p&gt;What if I have some raw data in a log file that you want to run through some processing (more complicated than an &lt;code&gt;awk&lt;/code&gt; one liner)? I write a simple python script that reads lines from &lt;code&gt;stdin&lt;/code&gt; and writes the processed sample to &lt;code&gt;stdout&lt;/code&gt;. If I do this, I can plot the result by doing&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat log.txt | ./process_script.py | feedgnuplot --lines --autolegend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or log it to another file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat log.txt | ./process_script.py &amp;gt; processed_data.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-interpret-packed-binary-data&#34;&gt;6. Interpret packed binary data&lt;/h2&gt;

&lt;p&gt;If the data in the log file, or data that&amp;rsquo;s coming in from a serial port or network interface is in some packed binary format, there&amp;rsquo;s a handy tool called &lt;code&gt;od&lt;/code&gt; that can interpret it on the fly.
The command below will interpret data coming in as packets of 8 bytes as 2 byte integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netcat -ul 9751 | od -An -td2 -w8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;od&lt;/code&gt; is a versatile tool and as is usual for linux programs, I recommend reading the &lt;a href=&#34;http://manpages.ubuntu.com/manpages/trusty/man1/od.1.html&#34; target=&#34;_blank&#34;&gt;manpage&lt;/a&gt; to know more about what it can do.&lt;/p&gt;

&lt;h2 id=&#34;7-process-plot-live-data-streams&#34;&gt;7. Process/Plot live data streams&lt;/h2&gt;

&lt;p&gt;If I have data coming in from from a serial port or from a network interface and I want to create a real-time plot, &lt;code&gt;feedgnuplot&lt;/code&gt; has an option for that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /dev/ttyUSB0 | feedgnuplot --lines --autolegend --xlen 100 --stream 0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;--xlen&lt;/code&gt; option plots a window of the last 100 samples and the &lt;code&gt;--stream&lt;/code&gt; option updates the plot as new data comes in. The parameter 0.1 is the refresh rate.&lt;/p&gt;

&lt;p&gt;I can even run the live data stream through my processing algorithm before plotting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netcat -ul 9750 | ./process_data.py | feedgnuplot --lines --autolegend --xlen 100 --stream 0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-redirecting-to-multiple-programs&#34;&gt;8. Redirecting to multiple programs.&lt;/h2&gt;

&lt;p&gt;Sometimes I&amp;rsquo;ve been in a situation where I want to monitor data coming in from a serial port &lt;em&gt;and&lt;/em&gt; log it to a file at the same time. One way of doing this is to write a python script that reads data from &lt;code&gt;stdin&lt;/code&gt;, logs it to a file and also writes the same data to &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /dev/ttyUSB0 | ./log_and_print.py | feedgnuplot --lines --xlen 100 --stream 0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is good if you only want to do one extra thing with the output. There is a better solution however that uses the &lt;code&gt;tee&lt;/code&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /dev/ttyUSB0 | tee &amp;gt;(command1) &amp;gt;(command2) &amp;gt;(logfile.txt) | feedgnuplot --lines --autolegend --xlen 100 --stream 0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This technique is quite versatile and can be used in many ways. For example, I can use tee to get the raw data from the serial port, plot it, pass it through a data processing script and plot the output of that result as well for a comparison.&lt;/p&gt;

&lt;h2 id=&#34;summing-up&#34;&gt;Summing up&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m sure that there are many more clever ways to combine and compose these commands to make prototyping easier as well as commands that I don&amp;rsquo;t know about yet. If there is one thing that I&amp;rsquo;ve learned after using linux for a few years it&amp;rsquo;s that it often has modest looking command line tools that can do much more than a lot of GUI based applications if you spend just a little time to go through the manpage. I hope that this post inspires others to take a second look at the free tools that come with most linux distros. Some of them could really simplify your workflow!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming Complex Dataflows in C</title>
      <link>http://www.ashwinnarayan.com/post/dataflow-programming-in-c/</link>
      <pubDate>Tue, 01 Aug 2017 00:15:14 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/dataflow-programming-in-c/</guid>
      <description>

&lt;p&gt;Over the past few months I&amp;rsquo;ve been spending a lot of time on implementing various signal processing algorithms in C/C++. Things like Kalman Filters, various types of FIR filters and finite state machines. The number of steps needed to implement each these algorithms were fairly small and in the beginning I tried to put all the functionality of these implementations into simple to use C++ classes. This made things look neater and also fit in quite well with the Arduino programming framework (I was implementing a lot of these algorithms on Arduino compatible microcontrollers like the Teensy). However, once I started combining different algorithms together to make something bigger, the code started becoming very messy. Making changes and debugging was starting to take longer and longer. In many instances, I had to go back and change the deisgn and interface of my C++ classes when I realized that the way I initially implemented it made it impossible or very difficult to do some step in the algorithm. I decided to take some time to figure out how I can do better. I wanted to find out a systematic method - a &amp;ldquo;meta-programming&amp;rdquo; algorithm if you will - that would tell me the way I should implement the algorithm so that the code is easy to write and more importantly, easy to read and debug.&lt;/p&gt;

&lt;h2 id=&#34;representing-the-algorithm&#34;&gt;Representing the Algorithm&lt;/h2&gt;

&lt;p&gt;Before I could start solving the problem I needed to decide how to represent a general data processing algorithm. What is a representation that can capture most if not all of the types of algorithms that I wanted to implement? I remembered that in a lot of papers that I&amp;rsquo;ve read, the authors used Simulink to implement their algorithm. So I decided to start out by assuming that I can represent what I want to do in the form of a block diagram - much like the block diagrams that you can draw in Simulink. It turns out that as long as they don&amp;rsquo;t have any cycles or loops, block diagrams with arrows representing the flow of data between the blocks can be represented by a mathematical structure called a Directed Acyclic Graph.&lt;/p&gt;

&lt;h2 id=&#34;directed-acyclic-graphs&#34;&gt;Directed Acyclic Graphs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Graph_theory&#34; target=&#34;_blank&#34;&gt;Graphs&lt;/a&gt; as a mathematical structure (different from the graphs that you use to plot data) are useful for representing relationships between things. Intuitively I think of them as circles connected by lines. The circles represent things and the lines represent some type of relationship between the things. If this seems very abstract, that&amp;rsquo;s because graphs can be applied to a &lt;em&gt;lot&lt;/em&gt; of different things and when an concept is that general, it tends to be very abstract. As an example, a graph can be used to represent an electrical circuit. Each discrete component like a resistor or an LED can be considered a node or vertex in the graph (circles). The wires that connect these components together can be considered the edges of the graph.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://imgs.xkcd.com/comics/collatz_conjecture.png&#34; alt=&#34;A graph representing the collatz sequence and some unrelated drawings.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        A graph representing the collatz sequence and some unrelated drawings.
        &lt;a href=&#34;https://xkcd.com/710/&#34;&gt; 
            Source: xkcd
        &lt;/a&gt; 
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph&#34; target=&#34;_blank&#34;&gt;directed graph&lt;/a&gt; is a graph in which the edges connecting the nodes have a direction. The graph in the image from xkcd is a directed graph since it has arrows connecting the nodes of the graph.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_acyclic_graph&#34; target=&#34;_blank&#34;&gt;directed acyclic graph&lt;/a&gt; (DAG) is a directed graph that does not have &lt;em&gt;cycles&lt;/em&gt; in it. This means that there is no way to start at a node in the graph and follow the arrows from node to node and reach the node you started at. A directed acyclic graph is useful for modeling dependencies. If you&amp;rsquo;re planning to understand some big concept in science - General Relativitiy for example - there are prerequisite ideas that you need to understand first. A subject and it&amp;rsquo;s prerequisites can be arranged in the form of a directed acyclic graph.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://www.ashwinnarayan.com/img/markov_chains.png&#34; alt=&#34;A directed acyclic graph showing the dependencies for learning about Markov Chains.&#34; /&gt;
    
    
    &lt;figcaption&gt;
        &lt;p&gt;
        A directed acyclic graph showing the dependencies for learning about Markov Chains.
        &lt;a href=&#34;https://metacademy.org&#34;&gt; 
            Source: Metacademy
        &lt;/a&gt; 
        &lt;/p&gt; 
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


&lt;h2 id=&#34;topological-sorting&#34;&gt;Topological Sorting&lt;/h2&gt;

&lt;p&gt;Given a DAG showing the dependencies for learning about Markov chains like in the image above, one might ask the question: Is there a way to list the nodes of the graph in correct learning order &lt;em&gt;i.e&lt;/em&gt; the order in which any dependencies for a node appear before the node itself is listed. It turns out that &lt;a href=&#34;https://en.wikipedia.org/wiki/Topological_sorting&#34; target=&#34;_blank&#34;&gt;you can&lt;/a&gt;! Every DAG has at least one way in which we can make this sorted list and there are a few algorithms for doing so.&lt;/p&gt;

&lt;p&gt;So if you want to learn something new, topologically sorting a dependency graph of the topic is a nice approach! In fact, this is exactly what the website &lt;a href=&#34;https://metacademy.org&#34; target=&#34;_blank&#34;&gt;Metacademy&lt;/a&gt; does! It gives you the order in which to learn things using topological sorting.&lt;/p&gt;

&lt;h2 id=&#34;dataflows&#34;&gt;Dataflows&lt;/h2&gt;

&lt;p&gt;So how does this relate to programming algorithms represented by block diagrams in C? I thought of the block diagram as a directed acyclic graph. The blocks which represent steps in the data processing algorithm are represented by nodes in the graph and the arrows that connect the blocks represent the flow of data. In programming, the nodes in the block diagram can be naturally represented by functions whose arguments are the incoming edges and the return values are the outgoing edges. This also means that the edges themselves can be naturally represented by variables in the C program. Once I&amp;rsquo;ve defined all the edge variables and block functions, I need to figure out what is the correct order in which to call each of these block functions. The &amp;ldquo;correct&amp;rdquo; order can be defined as the order in which each function is only called once all the variables that represent the input edges to the block have been updated (if necessary) in the current iteration of the main loop of the program. It turns out that this correct order is the same as the topologically sorted order of the function blocks.&lt;/p&gt;

&lt;p&gt;So to summarize the systematic meta algorithm to implement a data processing algorithm in C:&lt;/p&gt;

&lt;p&gt;Start out with a fresh &lt;code&gt;.h&lt;/code&gt; file which will contain your implementation&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Construct a block diagram of the algorithm showing the data flow.&lt;/li&gt;
&lt;li&gt;Make sure that the block diagram is a directed acyclic graph.&lt;/li&gt;
&lt;li&gt;Give names to each node and edge.&lt;/li&gt;
&lt;li&gt;For each edge in the graph, declare a C variable in the global scope. I use the &lt;code&gt;static&lt;/code&gt; keyword if I want to make sure that the variable is only visible inside the header file. The data type of the C variable depends on the node that the edge originates from.&lt;/li&gt;
&lt;li&gt;For each node in the graph, declare a function that takes as arguments pointers to both the input and and output edge variables from the node. It is useful to declare the input pointers as &lt;code&gt;const&lt;/code&gt; to ensure that the function does not modify the data in the edge variables. The function uses the input to carry out the processing step and modifies the output edge variables. I use &lt;code&gt;static&lt;/code&gt; variables inside the function if I need to keep track of any state (like for finite state machines).&lt;/li&gt;
&lt;li&gt;Any parameters needed by the processing step inside the function can either be declared globally or as a const argument of the function. Personally, I like to have the simple parameters as &lt;code&gt;#define&lt;/code&gt;s at the top of the header file so I can tweak/change them easily.&lt;/li&gt;
&lt;li&gt;If there are parameters that need to be modified/tuned during execution, they can be declared as variables global to the file. This is useful if you&amp;rsquo;re running a code that implements something like a PID controller and you want to tune the gains of the controller online. I use an &lt;a href=&#34;https://github.com/RationalAsh/CmdArduino&#34; target=&#34;_blank&#34;&gt;Arduino library&lt;/a&gt; that listens to incoming commands on one of the Serial ports.&lt;/li&gt;
&lt;li&gt;Define an initialization function that initializes all the edge variables to an initial state (if necessary).&lt;/li&gt;
&lt;li&gt;Define a main function graph execution function that calls the block functions in the topologically sorted order.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;rsquo;s a rough outline of what the &lt;code&gt;.h&lt;/code&gt; file will look like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#ifndef DATA_PROC_H
#define DATA_PROC_H

//#defines and parameters
#define PARAM1 0

//Define the edge variables with the appropriate type
float e1, e2, e3, e4
int e5;
//Define the node function prototypes
void F1(const float in1, const float in2, float *out);
void F2(const float in1, const float in2, float *out);
void F3(const float in1, int *out);

//Define the initialization function
void data_proc_init()
{
    e1 = 0;
    e2 = 0;
    e3 = 0;
    e4 = 0;
}

//Define the main execution pipeline function
void data_proc_exec()
{
    //Node functions called in the topologically sorted order
    F1(e1, e2, &amp;amp;e3);
    F2(e2, e3, &amp;amp;e4);
    F3(e4, &amp;amp;e5);
}

//Function implementations
//Implement the node functions here

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in the main C file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;quot;data_proc.h&amp;quot;

int main(int argc, char** argv)
{
    //Run the initialization function
    data_proc_init();

    while(loop_condition)
    {
        //Execute pipeline function in loop
        data_proc_exec();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve noticed that if I stick to these rules consistently, my code is generally much easier to read. As long as I give descriptive names to the block functions, I only need to look at the main execution function to figure out the flow of the program. Debugging becomes easier too! It becomes a matter of adding one function from the topologically sorted list at a time and checking the output for correctess.&lt;/p&gt;

&lt;p&gt;While the meta algorithm that I wrote down is specifically for C, this method can easily be extended to other programming languages. Python would make doing this even easier as it is much more flexible with functions returning data. Instead of taking in pointers to the output variables as arguments, the function can actually return tuples of data that can be assigned to the output edge variables.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m sure that this method will have some limitations. One I can see right away is that it uses a lot of variables. One for each edge and even more for the static variables inside the function. On memory constrained systems like small microcontrollers, the RAM can run out pretty fast (Declaring non-tweakable parameters as being stored in the code ROM should help with this a bit). Another problem is the question of what to do with algorithms that can&amp;rsquo;t be represented as a DAG. I don&amp;rsquo;t know if it&amp;rsquo;s possible to represent all possible algorithms using DAGs (A quick google search did not turn up any conclusive answers). I am also unsure how this model can be used for programming things like GUIs which sit around and wait for events to happen most of the time. However, when implementing control and signal processing algorithms, I find this method is singularly better than the others I&amp;rsquo;ve tried.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Real-Time Programming with Xenomai 3 - Part 2: Writing a simple periodic task.</title>
      <link>http://www.ashwinnarayan.com/post/xenomai-realtime-programming-part-2/</link>
      <pubDate>Sat, 20 May 2017 23:10:16 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/xenomai-realtime-programming-part-2/</guid>
      <description>&lt;p&gt;Xenomai gets tasks to run in real-time by having a co-kernel running alongside the regular linux kernel handling all the time critical tasks. The Xenomai co-kernel is able to do this because of the i-pipe patch that the custom kernel is compiled with. This patch adds an &lt;em&gt;interrupt pipeline&lt;/em&gt; that sits between the hardware of the computer and any kernels running on the hardware. The interrupt pipeline has domains which can be assigned a priority. When any interrupt, system call or processor fault comes in, the domain with the higher priority is allowed to process them first. The Xenomai co-kernel has the higher priority in an ipipe patched kernel. The Xenomai website has a &lt;a href=&#34;https://xenomai.org/documentation/branches/v2.3.x/Life-with-Adeos-rev_B.pdf&#34; target=&#34;_blank&#34;&gt;more detailed explanation of how it works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before I start with the explanation, here&amp;rsquo;s the full code and Makefile for those who just want to compile some code and get started. The documentation for all the functions used in the code and more can be found &lt;a href=&#34;https://xenomai.org/documentation/xenomai-3/pdf/xeno3prm.pdf&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;alchemy/task.h&amp;gt;
#include &amp;lt;alchemy/timer.h&amp;gt;
#include &amp;lt;math.h&amp;gt;


#define CLOCK_RES 1e-9 //Clock resolution is 1 ns by default
#define LOOP_PERIOD 1e7 //Expressed in ticks
//RTIME period = 1000000000;
RT_TASK loop_task;

void loop_task_proc(void *arg)
{
  RT_TASK *curtask;
  RT_TASK_INFO curtaskinfo;
  int iret = 0;

  RTIME tstart, now;

  curtask = rt_task_self();
  rt_task_inquire(curtask, &amp;amp;curtaskinfo);
  int ctr = 0;

  //Print the info
  printf(&amp;quot;Starting task %s with period of 10 ms ....\n&amp;quot;, curtaskinfo.name);

  //Make the task periodic with a specified loop period
  rt_task_set_periodic(NULL, TM_NOW, LOOP_PERIOD);

  tstart = rt_timer_read();

  //Start the task loop
  while(1){
    printf(&amp;quot;Loop count: %d, Loop time: %.5f ms\n&amp;quot;, ctr, (rt_timer_read() - tstart)/1000000.0);
    ctr++;
    rt_task_wait_period(NULL);
  }
}

int main(int argc, char **argv)
{
  char str[20];

  //Lock the memory to avoid memory swapping for this program
  mlockall(MCL_CURRENT | MCL_FUTURE);
    
  printf(&amp;quot;Starting cyclic task...\n&amp;quot;);

  //Create the real time task
  sprintf(str, &amp;quot;cyclic_task&amp;quot;);
  rt_task_create(&amp;amp;loop_task, str, 0, 50, 0);

  //Since task starts in suspended mode, start task
  rt_task_start(&amp;amp;loop_task, &amp;amp;loop_task_proc, 0);

  //Wait for Ctrl-C
  pause();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Makefile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;SKIN=alchemy
MAIN_SRC=cyclic_test
TARGET=cyclic_test

LM=-lm

CFLAGS := $(shell xeno-config --skin=alchemy --cflags)
LDFLAGS := $(LM) $(shell xeno-config --skin=alchemy --ldflags)
CC := $(shell xeno-config --cc)

$(TARGET): $(MAIN_SRC).c
	$(CC) -o $@ $&amp;lt; $(CFLAGS) $(LDFLAGS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, the headers, defines and global variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;
#include &amp;lt;alchemy/task.h&amp;gt;
#include &amp;lt;alchemy/timer.h&amp;gt;
#include &amp;lt;math.h&amp;gt;


#define CLOCK_RES 1e-9 //Clock resolution is 1 ns by default
#define LOOP_PERIOD 1e7 //Expressed in ticks
//RTIME period = 1000000000;
RT_TASK loop_task;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The includes are fairly standard. The Xenomai libraries are included by the &lt;code&gt;alchemy/task.h&lt;/code&gt; and the &lt;code&gt;alchemy/timer.h&lt;/code&gt; statements. I&amp;rsquo;ve deifined CLOCK_RES (The resolution of the clock) and LOOP_PERIOD (The period with which I want the periodic task to run) for convenience. The variable &lt;code&gt;RT_TASK loop_task&lt;/code&gt; will hold an address to a task descriptor for a Real-Time task/thread that Xenomai will create.&lt;/p&gt;

&lt;p&gt;Jumping ahead to &lt;code&gt;main()&lt;/code&gt;, the first line that you come across that might be unfamiliar is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;  //Lock the memory to avoid memory swapping for this program
  mlockall(MCL_CURRENT | MCL_FUTURE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The mlockall() function is actually a function provided by linux rather than Xenomai and is provided by the &lt;code&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/code&gt; include. In Part one, I talked about how a real-time task can miss its deadlines if the task is swapped out of memory by the operating system. This line of code makes sure that the memory that is currently mapped to the address space of the process as well as any memory that gets mapped into the address space of the process in the future is &amp;ldquo;locked&amp;rdquo; into RAM and cannot get swapped out.&lt;/p&gt;

&lt;p&gt;In the next few lines of code, a new real-time task is created.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;  //Create the real time task
  sprintf(str, &amp;quot;cyclic_task&amp;quot;);
  rt_task_create(&amp;amp;loop_task, str, 0, 50, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rt_task_create() function creates a new real-time task using Xenoma&amp;rsquo;s Alchemy API. The first argument is the RT_TASK variable that holds the address of the task descriptor. The second is a string that holds a name for the task. You can give it a descriptive name. The third argument is the size of the stack for the new task. Passing a zero makes the function use a system dependent default. The next argument is the &lt;em&gt;priority&lt;/em&gt; of the task. This tells the real-time scheduler how important the task is. Higher priority tasks can interrupt lower priority tasks. The last argument is the task creation mode into which you can pass bitwise OR&amp;rsquo;ed flags. For example, passing the T_JOINABLE flag allows you to call the rt_task_join() function to wait on the task to finish. In this code sample, I&amp;rsquo;m just passing in zero, which is the default mode. The function returns a 0 if the task is successfully created. Ideally, you should check for this and print an error if the return value is not zero. However, for this simple example, I&amp;rsquo;m omitting this.&lt;/p&gt;

&lt;p&gt;A real-time task created using rt_task_create() starts off dormant. To begin the execution of the task, you need to call the rt_task_start() function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;  //Since task starts in suspended mode, start task
  rt_task_start(&amp;amp;loop_task, &amp;amp;loop_task_proc, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two arguments are the task descriptor and a pointer to the function that implements the real-time task. The last argument is a pointer to a user defined struct that will be passed on as arguments to the real-time task function.&lt;/p&gt;

&lt;p&gt;Finally we call the pause() function and wait for a Ctrl-C signal from the terminal.&lt;/p&gt;

&lt;p&gt;Once rt_task_start() is called, the real-time task starts executing. To make a Xenomai task periodic, you need to call the rt_task_set_periodic() function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt; //Make the task periodic with a specified loop period
  rt_task_set_periodic(NULL, TM_NOW, LOOP_PERIOD);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re calling this function from outside a real-time task, you need to pass in an RT_TASK as the first argument. However, you can also call this function from inside a real-time task with a &lt;code&gt;NULL&lt;/code&gt; first argument. &lt;code&gt;TM_NOW&lt;/code&gt; tells Xenomai to start timing the task right away and LOOP period is the period of the task in ticks of the clock. Since the default resolution of the clock is 1 nanosecond, this argument is the same as the period you want for the task expressed in nanoseconds.&lt;/p&gt;

&lt;p&gt;Now we can start the infinite loop of the task.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;//Start the task loop
  while(1){
    printf(&amp;quot;Loop count: %d, Loop time: %.5f ms\n&amp;quot;, ctr, (rt_timer_read() - tstart)/1000000.0);
    ctr++;
    rt_task_wait_period(NULL);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the loop I increment a simple counter and also use the rt_timer_read() function to get the current system time so I can print to the terminal and check if the task is running in real-time. The rt_task_wait_period() blocks the loop till the start of the next period.&lt;/p&gt;

&lt;p&gt;When I started out trying to compile and run Xenomai with no prior experience, it seemed like quite a daunting task. The Xenomai documentation although excellent is written for programmers and as a result, it can be difficult to write your very first program. However, once you do write your very first program and you get a good idea for how it works, things go very smoothly. This post, like the one before is a bit long but hopefully, someone trying to get started with Xenomai for the first time will find it useful!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Real-Time Programming with Xenomai 3 - Part 1: Installation and Basic Setup</title>
      <link>http://www.ashwinnarayan.com/post/xenomai-realtime-programming/</link>
      <pubDate>Wed, 17 May 2017 00:07:36 +0800</pubDate>
      
      <guid>http://www.ashwinnarayan.com/post/xenomai-realtime-programming/</guid>
      <description>

&lt;p&gt;In my lab, we recently started moving away from Simulink&amp;rsquo;s Real-Time packages and towards Real-Time Linux for implementing the low level control of our robots. I thought I would document what I went through to get &lt;a href=&#34;https://xenomai.org/&#34; target=&#34;_blank&#34;&gt;Xenomai&lt;/a&gt; (A Real-Time framework for linux) working stably as a resource for others trying to get started on the same thing.&lt;/p&gt;

&lt;h2 id=&#34;what-is-real-time&#34;&gt;What is Real-Time?&lt;/h2&gt;

&lt;p&gt;The word &amp;ldquo;real-time&amp;rdquo; is used in a lot of different fields to mean different things. Some people also mistake real-time systems for high performance systems. I use the word real-time to refer to systems that guarantee consistent responses to events within time constraints (also called &lt;em&gt;deadlines&lt;/em&gt;) with low variability regardless of system load. This is something that&amp;rsquo;s not easy to do. A normal linux operating system is not real-time. Say you want to implement a program in C on a regular linux computer that toggles a pin on the parallel port every millisecond. A naive implementation would be as a simple loop that toggles the pin and waits for 1 millisecond. This may work OK most of the time but the moment the system is loaded by something else, the program may start running its loops slower because the process may be preempted by the kernel or be swapped out of memory in favor of another memory intensive program. A real-time operating system will be designed so that regardless of the system load, the program that toggles the pin can do the operation every millisecond give or take a few microseconds. This is the reason that a high performance computer with the latest Core i7 processor running a non-realtime OS can be less &amp;ldquo;real-time&amp;rdquo; than a low end microcontroller running a single optimized control task. Real-time systems are used in mission critical control systems such as those on fly-by-wire aircraft, satellites, exoplanetary rovers, cardiac pacemakers or car engine control units.&lt;/p&gt;

&lt;p&gt;A real-time operating system (RTOS) usually has an API for creating and running real-time tasks and uses a scheduling algorithm that&amp;rsquo;s different from what&amp;rsquo;s used by general purpose operating systems like Windows and Linux. There are many RTOSs in the wild. &lt;a href=&#34;https://en.wikipedia.org/wiki/Comparison_of_real-time_operating_systems&#34; target=&#34;_blank&#34;&gt;Wikipedia has a great list of them.&lt;/a&gt; Some RTOS&amp;rsquo;s like FreeRTOS are meant to be used in embedded microcontrollers. Some - like RTLinux are used when the real-time application needs to be run on a full blown operating system. Using real-time with full operating systems also allow you to take advantage of a lot of existing software and functionality that the operating system will have like networking and math libraries like GSL.&lt;/p&gt;

&lt;h2 id=&#34;real-time-operating-systems-for-control&#34;&gt;Real-Time Operating Systems for Control&lt;/h2&gt;

&lt;p&gt;When implementing a control system such as a PID controller digitally, real-time response times become very important. One of the assumptions made when developing digital control systems is that of constant sampling time. When you implement a control loop in code, if the constant sampling rate assumption is not met or if the controller responds too late to changes in the system state, it could lead to the system becoming unstable.&lt;/p&gt;

&lt;p&gt;The choice of using Xenomai to implement our real time controllers was mostly due to the fact that it has very good documentation apart from being free and open source.&lt;/p&gt;

&lt;h2 id=&#34;installing-xenomai&#34;&gt;Installing Xenomai&lt;/h2&gt;

&lt;p&gt;To get Xenomai running on a linux system, you need to compile a modified kernel. I used Lubuntu 12.04 (which ships with kernel 3.2). The version of the kernel that I compiled is 3.18.20. Choose a version of the kernel that is close in version number to the one that the distribution ships with to minimize issues.&lt;/p&gt;

&lt;p&gt;Before starting, create a fresh folder to act as your workspace. Also make sure you have plenty of disk space available. The 3.18.20 kernel requires just over 11 GB of free disk space to compile successfully. Newer versions of the kernel need more. 20 GB should be safe.&lt;/p&gt;

&lt;p&gt;These are the steps that I&amp;rsquo;ve been following to get a freshly installed Lubuntu system working with xenomai. Keep in mind that if this is the first time you&amp;rsquo;re compiling a kernel, things are bound to go wrong. Be willing to debug your compilation patiently. I had to go through the compilation process dozens of times, making tweaks at each step to get my first successful kernel image.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Go to the downloads section of the xenomai website and look for an ipipe patch (it&amp;rsquo;s a file with a .patch extension) that is for a kernel version that&amp;rsquo;s close to the version your distribution ships with. This is the kernel version that you&amp;rsquo;ll be compiling.&lt;/li&gt;
&lt;li&gt;Go to kernel.org and download the version of the linux kernel that exactly matches the kernel version on the ipipe patch file name.&lt;/li&gt;
&lt;li&gt;Download the xenomai source from the xenomai website.&lt;/li&gt;
&lt;li&gt;Unzip the files into separate folders.&lt;/li&gt;
&lt;li&gt;Apply the xenomai patch to the kernel:
&lt;code&gt;xenomai-3.0.4/scripts/prepare-kernel.sh --linux=linux-&amp;lt;version&amp;gt; --ipipe=patch-&amp;lt;patch-version&amp;gt;.patch --arch=x86_64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the kernel source directory and run &lt;code&gt;make menuconfig&lt;/code&gt; and make the following changes:

&lt;ul&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; CPU Frequency Scaling - DISABLE&lt;/li&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; ACPI Support -&amp;gt; Processor - DISABLE&lt;/li&gt;
&lt;li&gt;Power Management and ACPI Options -&amp;gt; CPU Idle -&amp;gt; CPU Idle PM Support - DISABLE&lt;/li&gt;
&lt;li&gt;Device Drivers -&amp;gt; Input Device Support -&amp;gt; Generic Input Layer -&amp;gt; Miscellaneous Devices -&amp;gt; PC Speaker Support - DISABLE&lt;/li&gt;
&lt;li&gt;Processor type and features -&amp;gt; Processor family: Select the exact processor on the motherboard. This is important for things to work properly.&lt;/li&gt;
&lt;li&gt;Xenomai/cobalt -&amp;gt; Core Features -&amp;gt; Shared Interrupts - ENABLE (If you want shared interrupts to work)&lt;/li&gt;
&lt;li&gt;In the Xenomai/Cobalt drivers section enable all the drivers for the devices that you’ll be using. Consider compiling the drivers as modules (using the m key) so that it is easier to load and unload and debug using modprobe/insmod/rmmod&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Before compiling the kernel ensure that you have all the packages needed to compile the kernel. Use apt-get or any package manager.

&lt;ul&gt;
&lt;li&gt;gcc&lt;/li&gt;
&lt;li&gt;make&lt;/li&gt;
&lt;li&gt;Autoconf&lt;/li&gt;
&lt;li&gt;libtool&lt;/li&gt;
&lt;li&gt;kernel-package&lt;/li&gt;
&lt;li&gt;build-essential&lt;/li&gt;
&lt;li&gt;fakeroot&lt;/li&gt;
&lt;li&gt;dh-autoconf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the kernel source folder again and compile the kernel using the command: &lt;code&gt;sudo CONCURRENCY_LEVEL=8 CLEAN_SOURCE=no fakeroot make-kpkg --initrd --append-to-version -xenomai-realtime --revision 1.0 kernel_image kernel_headers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Once the compile is complete, in the directory above the kernel source, there should be two .deb files: One starting with linux-headers and one starting with linux-image. These are the kernel image and header debian packages that you can use to install the kernel.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;sudo dpkg -i &amp;lt;package-name&amp;gt;&lt;/code&gt; to install each of the packages&lt;/li&gt;
&lt;li&gt;Update the initramfs using the command &lt;code&gt;sudo update-initramfs -c -k &amp;lt;kernel-version&amp;gt;-xenomai-realtime &amp;amp;&amp;amp; sudo update-grub&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd&lt;/code&gt; into the unzipped xenomai source folder and run &lt;code&gt;sudo ./configure&lt;/code&gt; followed by &lt;code&gt;sudo make &amp;amp;&amp;amp; make install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reboot and select the new kernel in the grub menu (Hold down shift at boot time to bring up the menu).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If everything went well, xenomai should be installed on your system now. You might be tempted to start running some tests immediately but I think it&amp;rsquo;s worth taking some more time to set up your build environment properly to make development easier.&lt;/p&gt;

&lt;p&gt;Some important xenomai related executables (including xeno-config) are in the &lt;code&gt;/usr/xenomai/bin&lt;/code&gt; folder. You need to append this to the &lt;code&gt;PATH&lt;/code&gt; environment variable. The library files that the code is linked against are installed in the &lt;code&gt;/usr/xenomai/lib&lt;/code&gt; folder. You need to append this to the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable. My preferred way of doing this is to edit the ~/.bashrc file with export statements. Open up your .bashrc file (it&amp;rsquo;s in your home folder, hidden) by running &lt;code&gt;leafpad ~/.bashrc&lt;/code&gt; and add the following two lines to it at the end.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export PATH=”/usr/xenomai/bin:$PATH”
export LD_LIBRARY_PATH=”/usr/xenomai/lib:$LD_LIBRARY_PATH”&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When you try to run a compiled xenomai application afterwards, you will need to run it as superuser (using the sudo command). It might complain that it cannot find the library files. This is because environment variables are cleared when running a program as root. To fix this permanently:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Open up a terminal and go to the &lt;code&gt;/etc/ld.so.conf.d&lt;/code&gt; folder.&lt;/li&gt;
&lt;li&gt;Create a new file called xenomai.conf (as superuser)&lt;/li&gt;
&lt;li&gt;Add the line &lt;code&gt;/usr/xenomai/lib&lt;/code&gt; to the file.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;sudo ldconfig&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Now&lt;/em&gt; you can finally try to run some tests. If everything went well, running &lt;code&gt;sudo /usr/xenomai/bin/latency&lt;/code&gt; should run the latency test program that outputs some numbers on to the terminal that shows you the latency figures of your system. It should be in the tens of microseconds range (If not something&amp;rsquo;s wrong).&lt;/p&gt;

&lt;p&gt;The process of getting real-time linux with Xenomai or any other framework running for the first time can be a little painful but once your installation is stable, it&amp;rsquo;ll serve you well for a very long time. Once you have a working compiled kernel package, installation on future hardware will also go much faster.&lt;/p&gt;

&lt;p&gt;In Part 2 of this series of blog posts, I will go through the process of writing a simple periodic real-time task using Xenomai&amp;rsquo;s real-time API.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Controlling music playback with a Telegram Bot</title>
      <link>http://www.ashwinnarayan.com/project/telegram-bot-music-control/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/telegram-bot-music-control/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Implementing Logistic Regression</title>
      <link>http://www.ashwinnarayan.com/project/logistic-regression/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/logistic-regression/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Simulating the chaos of a double pendulum</title>
      <link>http://www.ashwinnarayan.com/project/double-pendulum-simulation/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/double-pendulum-simulation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Visualizing Self-Organizing Maps</title>
      <link>http://www.ashwinnarayan.com/project/som-animation/</link>
      <pubDate>Sun, 14 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://www.ashwinnarayan.com/project/som-animation/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
